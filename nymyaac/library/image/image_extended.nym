// Extended Image Processing Library for NymyaLang
// Inspired by stb_image and stb_image_resize capabilities
// image_extended.nym

import image.image_basic

namespace image.extended

// Color manipulation functions
func grayscale(image: image.Image) -> image.Image {
    var result = image.image_basic.create_image(image.width, image.height, 1)  // New grayscale image
    
    for y in range(0, image.height) {
        for x in range(0, image.width) {
            var pixel = image.get_pixel(x, y)
            var gray_val = (pixel["r"] * 0.299 + pixel["g"] * 0.587 + pixel["b"] * 0.114) as Int
            result.set_pixel(x, y, gray_val, gray_val, gray_val)
        }
    }
    
    return result
}

func invert_colors(image: image.Image) -> image.Image {
    var result = image.image_basic.create_image(image.width, image.height, image.channels)
    
    for y in range(0, image.height) {
        for x in range(0, image.width) {
            var pixel = image.get_pixel(x, y)
            var r = 255 - pixel["r"]
            var g = 255 - pixel["g"]
            var b = 255 - pixel["b"]
            var a = pixel["a"]  // Alpha remains unchanged
            result.set_pixel(x, y, r, g, b, a)
        }
    }
    
    return result
}

func brighten(image: image.Image, factor: Float) -> image.Image {
    var result = image.image_basic.create_image(image.width, image.height, image.channels)
    
    for y in range(0, image.height) {
        for x in range(0, image.width) {
            var pixel = image.get_pixel(x, y)
            var r = min(255, (pixel["r"] as Float * factor) as Int)
            var g = min(255, (pixel["g"] as Float * factor) as Int)
            var b = min(255, (pixel["b"] as Float * factor) as Int)
            var a = pixel["a"]
            result.set_pixel(x, y, r, g, b, a)
        }
    }
    
    return result
}

func contrast(image: image.Image, factor: Float, midpoint: Int = 128) -> image.Image {
    var adjusted_factor = (259 * (factor + 255)) / (255 * (259 - factor))  // Contrast formula
    
    var result = image.image_basic.create_image(image.width, image.height, image.channels)
    
    for y in range(0, image.height) {
        for x in range(0, image.width) {
            var pixel = image.get_pixel(x, y)
            var r = clamp(((pixel["r"] - midpoint) * adjusted_factor) + midpoint, 0, 255) as Int
            var g = clamp(((pixel["g"] - midpoint) * adjusted_factor) + midpoint, 0, 255) as Int
            var b = clamp(((pixel["b"] - midpoint) * adjusted_factor) + midpoint, 0, 255) as Int
            var a = pixel["a"]
            result.set_pixel(x, y, r, g, b, a)
        }
    }
    
    return result
}

func clamp(value: Float, min_val: Int, max_val: Int) -> Float {
    if value < min_val as Float {
        return min_val as Float
    } else if value > max_val as Float {
        return max_val as Float
    } else {
        return value
    }
}

// Simple edge detection using a basic kernel
func detect_edges(image: image.Image) -> image.Image {
    var result = image.image_basic.create_image(image.width, image.height, 1)  // Result is grayscale
    
    // Simple 3x3 edge detection kernel
    var kernel = [
        [-1, -1, -1],
        [-1,  8, -1],
        [-1, -1, -1]
    ]
    
    for y in range(1, image.height - 1) {
        for x in range(1, image.width - 1) {
            var sum = 0
            for ky in range(-1, 2) {
                for kx in range(-1, 2) {
                    var pixel = image.get_pixel(x + kx, y + ky)
                    var gray = (pixel["r"] * 0.299 + pixel["g"] * 0.587 + pixel["b"] * 0.114) as Int
                    sum = sum + (gray * kernel[ky + 1][kx + 1])
                }
            }
            sum = abs(sum)
            var clamped_sum = min(255, max(0, sum))
            result.set_pixel(x, y, clamped_sum, clamped_sum, clamped_sum)
        }
    }
    
    return result
}

// Simple blur using averaging
func blur(image: image.Image, radius: Int = 1) -> image.Image {
    var result = image.image_basic.create_image(image.width, image.height, image.channels)
    
    for y in range(0, image.height) {
        for x in range(0, image.width) {
            var sum_r = 0
            var sum_g = 0
            var sum_b = 0
            var count = 0
            
            for dy in range(-radius, radius + 1) {
                for dx in range(-radius, radius + 1) {
                    var px = x + dx
                    var py = y + dy
                    
                    if px >= 0 and px < image.width and py >= 0 and py < image.height {
                        var pixel = image.get_pixel(px, py)
                        sum_r = sum_r + pixel["r"]
                        sum_g = sum_g + pixel["g"]
                        sum_b = sum_b + pixel["b"]
                        count = count + 1
                    }
                }
            }
            
            if count > 0 {
                var avg_r = sum_r / count
                var avg_g = sum_g / count
                var avg_b = sum_b / count
                result.set_pixel(x, y, avg_r, avg_g, avg_b)
            }
        }
    }
    
    return result
}

// Rotate image by 90 degrees clockwise
func rotate_90_clockwise(image: image.Image) -> image.Image {
    var result = image.image_basic.create_image(image.height, image.width, image.channels)
    
    for y in range(0, image.height) {
        for x in range(0, image.width) {
            var pixel = image.get_pixel(x, y)
            var new_x = image.height - 1 - y
            var new_y = x
            result.set_pixel(new_x, new_y, pixel["r"], pixel["g"], pixel["b"], pixel["a"])
        }
    }
    
    return result
}

// Convert image to ASCII art representation (fun feature)
func to_ascii_art(image: image.Image, ascii_chars: String = "@%#*+=-:. ") -> String {
    var result_lines = []
    
    // Process the image at a smaller scale to fit ASCII representation
    var scale_factor = max(1, image.width / 80)  // Adjust based on terminal width
    
    for y in range(0, image.height, scale_factor * 2) {  // Use double height scaling since chars are taller
        var line = ""
        for x in range(0, image.width, scale_factor) {
            var pixel = image.get_pixel(x, y)
            var brightness = (pixel["r"] * 0.299 + pixel["g"] * 0.587 + pixel["b"] * 0.114) as Int
            var char_idx = (brightness * (ascii_chars.length() - 1) / 255) as Int
            if char_idx >= ascii_chars.length() {
                char_idx = ascii_chars.length() - 1
            }
            line = line + ascii_chars[char_idx]
        }
        result_lines.append(line)
    }
    
    return "\n".join(result_lines)
}