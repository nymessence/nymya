// Utility functions for text processing and API client functionality
// utils.nym

import storygen.api_client
import storygen.config
import lowlevel.time

namespace storygen.utils

// Ensure defaults are initialized at module load
storygen.config.init_defaults()

// Placeholder for SequenceMatcher functionality - would need to be implemented in NymyaLang
func calculate_similarity(text1: String, text2: String) -> Float {
    // This is a simplified implementation
    // In a real implementation, this would use sequence matching algorithms
    var lower1 = text1.lower()
    var lower2 = text2.lower()
    
    if lower1 == lower2 {
        return 1.0
    }
    
    // Simple character overlap approach (simplified)
    var common_chars = 0
    var total_chars = max(lower1.length(), lower2.length())
    
    if total_chars == 0 {
        return 1.0
    }
    
    // A basic implementation for demonstration
    var min_len = min(lower1.length(), lower2.length())
    for i in range(0, min_len) {
        if lower1[i] == lower2[i] {
            common_chars = common_chars + 1
        }
    }
    
    return common_chars as Float / total_chars as Float
}

func estimate_tokens(text: String) -> Int {
    // Rough estimate of token count (approximately 4 characters per token for English)
    if text.length() == 0 {
        return 0
    }
    // More accurate estimation: ~0.75 tokens per word
    var words = text.split(" ")
    var word_count = words.length()
    var char_count = text.length()
    // Use whichever gives a more conservative (higher) estimate
    return max((word_count * 0.75) as Int, (char_count / 4) as Int)
}

func truncate_to_tokens(text: String, max_tokens: Int) -> String {
    // Truncate text to approximately max_tokens
    if text.length() == 0 {
        return ""
    }
    
    var current_tokens = estimate_tokens(text)
    if current_tokens <= max_tokens {
        return text
    }
    
    // Calculate approximate character limit
    var ratio = max_tokens as Float / current_tokens as Float
    var char_limit = (text.length() * ratio * 0.95) as Int  // 0.95 for safety margin
    
    var truncated = text[:char_limit]
    
    // Try to end at a sentence boundary
    var last_period = truncated.rfind(".")
    var last_newline = truncated.rfind("\n")
    
    var boundary = max(last_period, last_newline)
    if boundary > (char_limit * 0.7) as Int {  // Only use boundary if it's not too far back
        truncated = truncated[:boundary + 1]
    }
    
    return truncated.strip()
}

func trim_history_adaptive(history: List[Dict], max_tokens: Int) -> List[Dict] {
    // Adaptively trim conversation history to fit within token budget
    // Keeps most recent messages and removes repetitive content
    if history.length() == 0 {
        return []
    }
    
    // Always keep the last 6 messages
    var min_keep = min(6, history.length())
    var recent_history = history[-min_keep:]
    
    // Calculate tokens for recent messages
    var total_tokens = 0
    for msg in recent_history {
        if msg is Dict {
            total_tokens = total_tokens + estimate_tokens(msg.get("content", "").to_string())
        }
    }
    
    if total_tokens <= max_tokens {
        // If we have room, try to add more messages from earlier
        var remaining_tokens = max_tokens - total_tokens
        var extended_history = []
        
        for msg in reversed(history[:-min_keep]) {
            if not (msg is Dict) {
                continue
            }
            var msg_tokens = estimate_tokens(msg.get("content", "").to_string())
            if msg_tokens <= remaining_tokens {
                extended_history.insert(0, msg)
                remaining_tokens = remaining_tokens - msg_tokens
            } else {
                break
            }
        }
        
        return extended_history + recent_history
    }
    
    // If recent messages exceed budget, truncate them
    var trimmed = []
    var token_budget = max_tokens
    
    for msg in reversed(recent_history) {
        if not (msg is Dict) {
            continue
        }
        
        var content = msg.get("content", "").to_string()
        var msg_tokens = estimate_tokens(content)
        
        if msg_tokens <= token_budget {
            trimmed.insert(0, msg)
            token_budget = token_budget - msg_tokens
        } else {
            // Truncate this message to fit
            var truncated_content = truncate_to_tokens(content, token_budget)
            if truncated_content.length() > 0 {
                trimmed.insert(0, {
                    "name": msg.get("name", "Unknown"),
                    "content": truncated_content
                })
            }
            break
        }
    }
    
    return trimmed
}

func remove_repetitive_phrases(text: String, history: List[Dict], threshold: Float = 0.7) -> String {
    // Remove phrases from text that are too similar to recent history
    if history.length() == 0 or text.length() == 0 {
        return text
    }
    
    // Get recent content
    var recent_contents = []
    for msg in history[-5:] {
        if msg is Dict {
            recent_contents.append(msg.get("content", "").to_string())
        }
    }
    
    // Split text into sentences
    var sentences = []
    var parts = text.split(".")
    for s in parts {
        if s.strip().length() > 0 {
            sentences.append(s.strip() + ".")
        }
    }
    
    var filtered_sentences = []
    for sentence in sentences {
        // Check if this sentence is too similar to any recent content
        var is_repetitive = False
        for recent in recent_contents {
            var similarity = calculate_similarity(sentence, recent)
            if similarity > threshold {
                is_repetitive = True
                break
            }
        }
        
        if not is_repetitive {
            filtered_sentences.append(sentence)
        }
    }
    
    var result = " ".join(filtered_sentences)
    
    // If we filtered out everything, return the original
    if result.strip().length() == 0 {
        return text
    }
    
    return result
}

// Re-export the API call function from api_client to make it available here too
func make_api_call(prompt: String, max_tokens: Int = 150, temperature: Float = 0.7, 
                 stop: List[String] = [], verbose: Bool = False) -> String {
    return storygen.api_client.make_api_call(prompt, max_tokens, temperature, stop, verbose)
}