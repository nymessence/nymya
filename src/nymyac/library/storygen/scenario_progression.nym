// Scenario progression system for advancing conversations through different stages
// scenario_progression.nym

import storygen.api_client
import storygen.config
import lowlevel.string

namespace storygen.scenario_progression

// Ensure defaults are initialized at module load
storygen.config.init_defaults()

class ScenarioProgressor {
    var initial_scenario
    var progression_completed
    var progression_history
    var last_progression_turn
    var generated_stage_sequence
    var current_stage_idx
    var current_stage
    var stage_descriptions
    var stage_transitions
    var stage_guidances
    var dynamic_scenario_context
    
    func init(initial_scenario: String) -> Void {
        self.initial_scenario = initial_scenario
        self.progression_completed = False
        self.progression_history = []
        self.last_progression_turn = 0
        self.generated_stage_sequence = []
        self.current_stage_idx = 0
        self.current_stage = ""
        self.stage_descriptions = {}
        self.stage_transitions = {}
        self.stage_guidances = {}
        self.dynamic_scenario_context = initial_scenario
        
        // Generate the progression sequence based on the initial scenario
        self._generate_progression_sequence()
        
        // Set initial stage if sequence was generated
        if self.generated_stage_sequence.length() > 0 {
            self.current_stage = self.generated_stage_sequence[0] if self.generated_stage_sequence.length() > 0 else "initial"
        } else {
            self.current_stage = "initial"  // fallback
        }
    }
    
    func _generate_progression_sequence(self) -> Void {
        // Generate a custom progression sequence based on the initial scenario using AI
        try {
            var prompt = "Based on this scenario, generate a logical progression sequence of 3-7 stages that the story might follow. Each stage should be a natural evolution from the previous one.\n\nSCENARIO: " + self.initial_scenario + "\n\nGenerate a progression sequence as a numbered list. Each stage should:\n1. Be a natural progression from the previous stage\n2. Be specific to the scenario context\n3. Be something characters can have meaningful conversations about\n4. Have a clear connection to the story flow\n\nFormat:\n1. [Stage name]: [Brief description]\n2. [Stage name]: [Brief description]\n...\n\nExample for space travel scenario:\n1. Pre-launch preparations: Characters prepare for space travel\n2. Initial space travel: Early phase of journey through space\n3. Mid-journey challenges: Obstacles or discoveries during travel\n4. Approach destination: Getting close to target location\n5. Atmospheric entry: Entering planet's atmosphere if applicable\n6. Landing procedures: Safe landing sequence\n7. Surface exploration: Exploring the new environment\n\nNow generate for the given scenario:"
            
            var response = storygen.api_client.make_api_call(prompt, 300, 0.7, [], False)
            
            // Parse the response to extract stage names
            var stages = []
            var descriptions = {}
            var guidances = {}
            var transitions = {}
            
            // First, collect all valid stage lines
            var valid_stage_lines = []
            for line in response.split("\n") {
                line = line.strip()
                // Look for lines that start with an incremental number followed by a period (e.g., "1.", "2.", "3.", etc.)
                for expected_num in range(1, 20) {  // Reasonable range for stages
                    if line.startswith(expected_num.to_string() + ". ") or line.startswith(expected_num.to_string() + ".") {
                        // Extract stage name and description
                        var parts = line.split(":", 1)  // Split on first colon only
                        if parts.length() >= 2 {
                            var stage_part = parts[0].split(".", 1)[-1].strip()  // Remove the number
                            var desc_part = parts[1].strip()
                            valid_stage_lines.append([expected_num, stage_part, desc_part])
                        }
                        break  // Stop checking other numbers once we find a match
                    }
                }
            }
            
            // Process the valid lines in order to maintain sequence
            for num, stage_part, desc_part in sorted(valid_stage_lines, key=lambda x: x[0]) {
                // Create a clean stage identifier
                var stage_id = self._clean_stage_name(stage_part)
                if not (stage_id in stages) {  // Avoid duplicates
                    stages.append(stage_id)
                    descriptions[stage_id] = desc_part
                    guidances[stage_id] = "During this stage: " + desc_part + ". Characters should react to this development."
                }
            }
            
            // If parsing failed, create a generic sequence based on keywords
            if stages.length() == 0 {
                var scenario_lower = self.initial_scenario.to_lower()
                if any_keyword_in_string(['warp', 'space', 'spacecraft', 'travel', 'departed earth'], scenario_lower) {
                    stages = ['departure', 'space_travel', 'mid_journey', 'approach', 'entry', 'landing', 'surface']
                    descriptions = {
                        'departure': 'Departing from the starting location',
                        'space_travel': 'Journeying through space',
                        'mid_journey': 'Mid-point developments during travel',
                        'approach': 'Approaching the destination',
                        'entry': 'Entering the destination environment',
                        'landing': 'Landing or docking procedures',
                        'surface': 'Surface activities at destination'
                    }
                    guidances = {k: "Focus on this phase: " + v for k, v in descriptions}
                }
            }
            
            // Generate default transitions if not created
            if transitions.length() == 0 and stages.length() > 0 {
                for i in range(1, stages.length()) {  // Skip first stage as it's initial
                    var from_stage = stages[i-1]
                    var to_stage = stages[i]
                    transitions[to_stage] = "Moving from " + from_stage.replace("_", " ") + " to " + to_stage.replace("_", " ")
                }
            }
            
            self.generated_stage_sequence = stages
            self.stage_descriptions = descriptions
            self.stage_guidances = guidances
            self.stage_transitions = transitions

            // Generate transition messages between stages
            for i in range(1, stages.length()) {
                var from_stage = stages[i-1]
                var to_stage = stages[i]
                var transition_prompt = "Generate a narrative transition message for moving from stage '" + from_stage + "' to stage '" + to_stage + "' in this scenario: " + self.initial_scenario + "\n\nThe transition should be engaging and contextually appropriate. Keep it to 1-2 sentences.\n\nTransition message:"

                try {
                    var transition_msg = storygen.api_client.make_api_call(transition_prompt, 100, 0.8, [], False)
                    // Clean up the response
                    transition_msg = transition_msg.split("\n")[0] if transition_msg else "Moving to next phase: " + to_stage
                    self.stage_transitions[to_stage] = transition_msg
                } catch error {
                    self.stage_transitions[to_stage] = "Moving from " + from_stage.replace("_", " ") + " to " + to_stage.replace("_", " ")
                }
            }

        } catch error {
            crystal.manifest("⚠️  AI progression generation failed, using fallback: " + error.to_string())
            // Fallback to basic progression
            self._generate_fallback_progression()
        }
    }
    
    func _clean_stage_name(self, stage_text: String) -> String {
        // Convert stage text to a clean identifier
        // Remove special characters, replace spaces with underscores
        var cleaned = lowlevel.string.replace_regex(stage_text, "[^\\w\\s-]", "")
        cleaned = lowlevel.string.replace_all(cleaned, " ", "_").to_lower()
        return cleaned if cleaned.length() > 0 else "stage"
    }
    
    func _generate_fallback_progression(self) -> Void {
        // Generate a fallback progression sequence
        var scenario_lower = self.initial_scenario.to_lower()

        if any_keyword_in_string(['warp', 'space', 'spacecraft', 'travel', 'departed earth'], scenario_lower) {
            var stages = ['warp_travel', 'mid_journey', 'approach', 'descent', 'landing', 'surface_arrival']
        } else if any_keyword_in_string(['battle', 'combat', 'war', 'fight'], scenario_lower) {
            var stages = ['preparation', 'encounter', 'battle', 'lull', 'aftermath', 'recovery']
        } else if any_keyword_in_string(['negotiation', 'talk', 'meeting', 'discussion'], scenario_lower) {
            var stages = ['introductions', 'topic_introduction', 'tension', 'compromise', 'agreement', 'follow_up']
        } else {
            var stages = ['beginning', 'development', 'conflict', 'resolution', 'conclusion']
        }

        self.generated_stage_sequence = stages
        self.stage_descriptions = {stage: "Stage: " + stage.replace("_", " ") for stage in stages}
        self.stage_guidances = {stage: "Focus on this stage: " + stage.replace("_", " ") for stage in stages}
        // Generate basic transitions
        for i in range(1, stages.length()) {
            self.stage_transitions[stages[i]] = "Transitioning from " + stages[i-1] + " to " + stages[i]
        }
    }
    
    func get_current_stage_description(self) -> String {
        // Get the description for the current stage
        return self.stage_descriptions.get(self.current_stage, "In stage: " + self.current_stage)
    }
    
    func should_advance_stage(self, history: List[Dict], turn: Int) -> Bool {
        // Determine if we should advance to the next stage
        if self.progression_completed {
            return False
        }

        // Don't advance if we already advanced recently (avoid rapid advancement)
        if turn - self.last_progression_turn < 20 {  // Wait at least 20 turns between progressions
            return False
        }

        // Check if we're already at the last stage
        var next_idx = self.current_stage_idx + 1
        if next_idx >= self.generated_stage_sequence.length() {
            // We're at the final stage, mark progression as completed and return False
            self.progression_completed = True
            return False
        }

        // Advance every 40 turns, but don't advance too frequently
        if turn % 40 == 0 and turn > 0 {
            return True
        }

        // Check if we've been in the same stage for too long
        // Use the length of history directly (should be efficient)
        if history.length() > 50 {
            return True
        }

        return False
    }
    
    func advance_stage(self, history: List[Dict], current_turn: Int = 0) -> String {
        // Advance to the next stage in the progression
        var next_idx = self.current_stage_idx + 1

        if next_idx < self.generated_stage_sequence.length() {
            // Move to the next stage
            self.progression_history.append(self.current_stage)
            self.current_stage_idx = next_idx
            self.current_stage = self.generated_stage_sequence[next_idx]
            self.last_progression_turn = current_turn  // Track when progression happened

            // Get the transition message for this specific stage
            var transition_msg = self.stage_transitions.get(self.current_stage, "Advancing to stage: " + self.current_stage)
            return transition_msg
        } else {
            // No more stages to advance to, mark as completed
            self.progression_completed = True
            return ""
        }
    }
    
    func get_scenario_context_for_stage(self) -> String {
        // Get the scenario context for the current stage
        var base_context = self.dynamic_scenario_context  // Use dynamic context that can be updated by story flow

        var stage_description = self.stage_descriptions.get(self.current_stage, "Currently in the " + self.current_stage + " phase")

        if self.current_stage in self.stage_descriptions {
            return base_context + " " + stage_description
        } else {
            return base_context
        }
    }
    
    func get_stage_guidance(self) -> String {
        // Get guidance for the current stage
        return self.stage_guidances.get(self.current_stage, "Continue the conversation naturally.")
    }

    func update_scenario_context_from_story_flow(self, history: List[Dict], turn: Int) -> String {
        /*
         * Analyze the story flow and update the scenario context dynamically
         * This allows the scenario to evolve based on character interactions
         */
        try {
            if not history.length() > 0 {
                return self.dynamic_scenario_context
            }

            // Get recent history (last few exchanges) to analyze story flow
            var recent_history = history[-6:] if history.length() >= 6 else history  // Get last ~3 exchanges

            // Create a summary of recent conversation
            var conversation_summary = []
            for entry in recent_history {
                if entry is Dict and entry.contains('name') and entry.contains('content') {
                    var content_part = entry['content']
                    if content_part.length() > 200 {
                        content_part = content_part[:200]  // Limit length
                    }
                    conversation_summary.append(entry['name'] + ": " + content_part)
                }
            }

            var summary_text = "\n".join(conversation_summary)

            // Create prompt to analyze story evolution
            var prompt = "Analyze this recent conversation and update the scenario context to reflect how the story has evolved.\n\nORIGINAL SCENARIO: " + self.initial_scenario + "\n\nRECENT CONVERSATION:\n" + summary_text + "\n\nCURRENT STAGE: " + self.current_stage + "\nCURRENT STAGE DESCRIPTION: " + self.stage_descriptions.get(self.current_stage, 'No description') + "\n\nBased on the conversation flow, provide an updated scenario context that reflects new developments, character discoveries, plot twists, or evolving situation. Keep it concise but meaningful. The updated context should maintain the core scenario while incorporating story developments.\n\nUpdated scenario context:"

            var updated_context = storygen.api_client.make_api_call(prompt, 200, 0.7, [], False)

            if updated_context and updated_context.strip().length() > 0 {
                self.dynamic_scenario_context = updated_context.strip()
                return self.dynamic_scenario_context
            }
        } catch error {
            crystal.manifest("⚠️  Failed to update scenario context from story flow: " + error.to_string())
        }

        // Return current context if update failed
        return self.dynamic_scenario_context
    }
}

func check_scenario_progression(scenario_progressor: ScenarioProgressor, history: List[Dict], turn: Int) -> String {
    // Check if scenario progression is needed and advance if appropriate
    // First, update the scenario context based on story flow
    scenario_progressor.update_scenario_context_from_story_flow(history, turn)

    if scenario_progressor.should_advance_stage(history, turn) {
        var transition_message = scenario_progressor.advance_stage(history, turn)
        return transition_message
    }
    return ""
}

// Helper function to check if any keyword is in a string
func any_keyword_in_string(keywords: List[String], text: String) -> Bool {
    for keyword in keywords {
        if keyword in text.to_lower() {
            return True
        }
    }
    return False
}