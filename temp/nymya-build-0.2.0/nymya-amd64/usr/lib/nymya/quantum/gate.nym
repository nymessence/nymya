// Quantum Gates Library
// Implements standard quantum gates based on quantum computing standards from the wiki

import math
import quantum.sim

namespace quantum {
    namespace gate {

        // Identity gate and global phase
        func id(circuit: quantum.sim.Circuit, qubit: Int) -> Void {
            // Identity gate = [[1, 0], [0, 1]]
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(1.0, 0.0)]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        // Clifford gates
        func x(circuit: quantum.sim.Circuit, qubit: Int) -> Void {
            // Pauli X = [[0, 1], [1, 0]]
            var gate_matrix = [
                [math.Complex(0.0, 0.0), math.Complex(1.0, 0.0)],
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        func y(circuit: quantum.sim.Circuit, qubit: Int) -> Void {
            // Pauli Y = [[0, -i], [i, 0]]
            var gate_matrix = [
                [math.Complex(0.0, 0.0), math.Complex(0.0, -1.0)],
                [math.Complex(0.0, 1.0), math.Complex(0.0, 0.0)]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        func z(circuit: quantum.sim.Circuit, qubit: Int) -> Void {
            // Pauli Z = [[1, 0], [0, -1]]
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(-1.0, 0.0)]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        func s(circuit: quantum.sim.Circuit, qubit: Int) -> Void {
            // S gate (Phase gate) = [[1, 0], [0, i]]
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 1.0)]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        func sdg(circuit: quantum.sim.Circuit, qubit: Int) -> Void {
            // S-dagger gate = [[1, 0], [0, -i]]
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, -1.0)]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        func sx(circuit: quantum.sim.Circuit, qubit: Int) -> Void {
            // Square root of X gate = [[1+i, 1-i], [1-i, 1+i]]/2
            var gate_matrix = [
                [math.Complex(0.5, 0.5), math.Complex(0.5, -0.5)],
                [math.Complex(0.5, -0.5), math.Complex(0.5, 0.5)]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        func h(circuit: quantum.sim.Circuit, qubit: Int) -> Void {
            // Hadamard gate = [[1, 1], [1, -1]]/√2
            var sqrt2_inv = 1.0 / math.sqrt(2.0)
            var gate_matrix = [
                [math.Complex(sqrt2_inv, 0.0), math.Complex(sqrt2_inv, 0.0)],
                [math.Complex(sqrt2_inv, 0.0), math.Complex(-sqrt2_inv, 0.0)]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        // Two-qubit gates
        func cx(circuit: quantum.sim.Circuit, control: Int, target: Int) -> Void {
            // CNOT gate = [[1,0,0,0], [0,1,0,0], [0,0,0,1], [0,0,1,0]]
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)]
            ]
            circuit.apply_two_qubit_gate(control, target, gate_matrix)
        }

        func cy(circuit: quantum.sim.Circuit, control: Int, target: Int) -> Void {
            // Controlled-Y gate = [[1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,-i]]
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, -1.0), math.Complex(0.0, 0.0)]
            ]
            circuit.apply_two_qubit_gate(control, target, gate_matrix)
        }

        func cz(circuit: quantum.sim.Circuit, control: Int, target: Int) -> Void {
            // Controlled-Z gate = [[1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,-1]]
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(-1.0, 0.0)]
            ]
            circuit.apply_two_qubit_gate(control, target, gate_matrix)
        }

        func swap(circuit: quantum.sim.Circuit, qubit1: Int, qubit2: Int) -> Void {
            // SWAP gate = [[1,0,0,0], [0,0,1,0], [0,1,0,0], [0,0,0,1]]
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0)]
            ]
            circuit.apply_two_qubit_gate(qubit1, qubit2, gate_matrix)
        }

        func iswap(circuit: quantum.sim.Circuit, qubit1: Int, qubit2: Int) -> Void {
            // Imaginary SWAP gate = [[1,0,0,0], [0,0,i,0], [0,i,0,0], [0,0,0,1]]
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 1.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 1.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0)]
            ]
            circuit.apply_two_qubit_gate(qubit1, qubit2, gate_matrix)
        }

        // Non-Clifford gates
        func t(circuit: quantum.sim.Circuit, qubit: Int) -> Void {
            // T gate (π/8 gate) = [[1, 0], [0, e^(iπ/4)]]
            var pi_over_4 = math.PI / 4.0
            var phase = math.Complex(math.cos(pi_over_4), math.sin(pi_over_4))
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), phase]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        func tdg(circuit: quantum.sim.Circuit, qubit: Int) -> Void {
            // T-dagger = [[1, 0], [0, e^(-iπ/4)]]
            var pi_over_4 = math.PI / 4.0
            var phase = math.Complex(math.cos(-pi_over_4), math.sin(-pi_over_4))
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), phase]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        func p(circuit: quantum.sim.Circuit, qubit: Int, phi: Float) -> Void {
            // Phase shift gate P(φ) = [[1, 0], [0, e^(iφ)]]
            var phase = math.Complex(math.cos(phi), math.sin(phi))
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), phase]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        // Rotation gates
        func rx(circuit: quantum.sim.Circuit, qubit: Int, theta: Float) -> Void {
            // Rx(θ) = [[cos(θ/2), -i*sin(θ/2)], [-i*sin(θ/2), cos(θ/2)]]
            var cos_half = math.cos(theta / 2.0)
            var sin_half = math.sin(theta / 2.0)
            var gate_matrix = [
                [math.Complex(cos_half, 0.0), math.Complex(0.0, -sin_half)],
                [math.Complex(0.0, -sin_half), math.Complex(cos_half, 0.0)]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        func ry(circuit: quantum.sim.Circuit, qubit: Int, theta: Float) -> Void {
            // Ry(θ) = [[cos(θ/2), -sin(θ/2)], [sin(θ/2), cos(θ/2)]]
            var cos_half = math.cos(theta / 2.0)
            var sin_half = math.sin(theta / 2.0)
            var gate_matrix = [
                [math.Complex(cos_half, 0.0), math.Complex(-sin_half, 0.0)],
                [math.Complex(sin_half, 0.0), math.Complex(cos_half, 0.0)]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        func rz(circuit: quantum.sim.Circuit, qubit: Int, phi: Float) -> Void {
            // Rz(φ) = [[e^(-iφ/2), 0], [0, e^(iφ/2)]]
            var neg_phase = math.Complex(math.cos(-phi/2.0), math.sin(-phi/2.0))
            var pos_phase = math.Complex(math.cos(phi/2.0), math.sin(phi/2.0))
            var gate_matrix = [
                [neg_phase, math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), pos_phase]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        // Controlled phase gates
        func cp(circuit: quantum.sim.Circuit, control: Int, target: Int, lambda: Float) -> Void {
            // Controlled-P gate = [[1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,e^(iλ)]]
            var phase = math.Complex(math.cos(lambda), math.sin(lambda))
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), phase]
            ]
            circuit.apply_two_qubit_gate(control, target, gate_matrix)
        }

        func cs(circuit: quantum.sim.Circuit, control: Int, target: Int) -> Void {
            // Controlled-S gate = [[1,0,0,0], [0,1,0,0], [0,0,1,0], [0,0,0,i]]
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 1.0)]
            ]
            circuit.apply_two_qubit_gate(control, target, gate_matrix)
        }

        // Two-qubit interaction gates
        func rxx(circuit: quantum.sim.Circuit, qubit1: Int, qubit2: Int, phi: Float) -> Void {
            // XX interaction gate = exp(-iφ/2 * X⊗X)
            var cos_half = math.cos(phi / 2.0)
            var sin_half = math.sin(phi / 2.0)
            var gate_matrix = [
                [math.Complex(cos_half, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, -sin_half)],
                [math.Complex(0.0, 0.0), math.Complex(cos_half, 0.0), math.Complex(0.0, -sin_half), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, -sin_half), math.Complex(cos_half, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, -sin_half), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(cos_half, 0.0)]
            ]
            circuit.apply_two_qubit_gate(qubit1, qubit2, gate_matrix)
        }

        func ryy(circuit: quantum.sim.Circuit, qubit1: Int, qubit2: Int, phi: Float) -> Void {
            // YY interaction gate = exp(-iφ/2 * Y⊗Y)
            var cos_half = math.cos(phi / 2.0)
            var sin_half = math.sin(phi / 2.0)
            var gate_matrix = [
                [math.Complex(cos_half, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, sin_half)],
                [math.Complex(0.0, 0.0), math.Complex(cos_half, 0.0), math.Complex(0.0, -sin_half), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, -sin_half), math.Complex(cos_half, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, sin_half), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(cos_half, 0.0)]
            ]
            circuit.apply_two_qubit_gate(qubit1, qubit2, gate_matrix)
        }

        func rzz(circuit: quantum.sim.Circuit, qubit1: Int, qubit2: Int, phi: Float) -> Void {
            // ZZ interaction gate = exp(-iφ/2 * Z⊗Z)
            var neg_phase = math.Complex(math.cos(-phi/2.0), math.sin(-phi/2.0))
            var pos_phase = math.Complex(math.cos(phi/2.0), math.sin(phi/2.0))
            var gate_matrix = [
                [neg_phase, math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), pos_phase, math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), pos_phase, math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), neg_phase]
            ]
            circuit.apply_two_qubit_gate(qubit1, qubit2, gate_matrix)
        }

        // Three-qubit gates
        func ccx(circuit: quantum.sim.Circuit, control1: Int, control2: Int, target: Int) -> Void {
            // Toffoli (CCX) gate - flips target if both controls are |1⟩
            // Matrix: |000⟩→|000⟩, |001⟩→|001⟩, |010⟩→|010⟩, |011⟩→|011⟩, |100⟩→|100⟩, |101⟩→|101⟩, |110⟩→|111⟩, |111⟩→|110⟩
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)], // |000⟩
                [math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)], // |001⟩
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)], // |010⟩
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)], // |011⟩
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)], // |100⟩
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)], // |101⟩
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0)], // |110⟩
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)]  // |111⟩
            ]
            circuit.apply_three_qubit_gate(control1, control2, target, gate_matrix)
        }

        func cswap(circuit: quantum.sim.Circuit, control: Int, target1: Int, target2: Int) -> Void {
            // Fredkin (CSWAP) gate - swaps targets if control is |1⟩
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)], // |000⟩
                [math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)], // |001⟩
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)], // |010⟩
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)], // |011⟩
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)], // |100⟩
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)], // |101⟩
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0)], // |110⟩
                [math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(0.0, 0.0), math.Complex(1.0, 0.0)]  // |111⟩
            ]
            circuit.apply_three_qubit_gate(control, target1, target2, gate_matrix)
        }

        // General single qubit rotation gate
        func u(circuit: quantum.sim.Circuit, qubit: Int, theta: Float, phi: Float, lambda: Float) -> Void {
            // U(θ,φ,λ) = [[cos(θ/2), -e^(iλ)sin(θ/2)], [e^(iφ)sin(θ/2), e^(i(φ+λ))cos(θ/2)]]
            var cos_half = math.cos(theta / 2.0)
            var sin_half = math.sin(theta / 2.0)
            var e_ilambda = math.Complex(math.cos(lambda), math.sin(lambda))
            var e_iphi = math.Complex(math.cos(phi), math.sin(phi))
            var e_iphi_lambda = math.Complex(math.cos(phi + lambda), math.sin(phi + lambda))

            var gate_matrix = [
                [math.Complex(cos_half, 0.0), e_ilambda.multiply(math.Complex(-sin_half, 0.0))],
                [e_iphi.multiply(math.Complex(sin_half, 0.0)), e_iphi_lambda.multiply(math.Complex(cos_half, 0.0))]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        func u1(circuit: quantum.sim.Circuit, qubit: Int, lambda: Float) -> Void {
            // U1(λ) = [[1, 0], [0, e^(iλ)]] - equivalent to rz up to a phase
            var phase = math.Complex(math.cos(lambda), math.sin(lambda))
            var gate_matrix = [
                [math.Complex(1.0, 0.0), math.Complex(0.0, 0.0)],
                [math.Complex(0.0, 0.0), phase]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        func u2(circuit: quantum.sim.Circuit, qubit: Int, phi: Float, lambda: Float) -> Void {
            // U2(φ,λ) = 1/√2 * [[1, -e^(iλ)], [e^(iφ), e^(i(φ+λ))]]
            var sqrt2_inv = 1.0 / math.sqrt(2.0)
            var e_ilambda = math.Complex(math.cos(lambda), math.sin(lambda))
            var e_iphi = math.Complex(math.cos(phi), math.sin(phi))
            var e_iphi_lambda = math.Complex(math.cos(phi + lambda), math.sin(phi + lambda))

            var gate_matrix = [
                [math.Complex(sqrt2_inv, 0.0), e_ilambda.multiply(math.Complex(-sqrt2_inv, 0.0))],
                [e_iphi.multiply(math.Complex(sqrt2_inv, 0.0)), e_iphi_lambda.multiply(math.Complex(sqrt2_inv, 0.0))]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        func u3(circuit: quantum.sim.Circuit, qubit: Int, theta: Float, phi: Float, lambda: Float) -> Void {
            // U3(θ,φ,λ) = [[cos(θ/2), -e^(iλ)sin(θ/2)], [e^(iφ)sin(θ/2), e^(i(φ+λ))cos(θ/2)]]
            var cos_half = math.cos(theta / 2.0)
            var sin_half = math.sin(theta / 2.0)
            var e_ilambda = math.Complex(math.cos(lambda), math.sin(lambda))
            var e_iphi = math.Complex(math.cos(phi), math.sin(phi))
            var e_iphi_lambda = math.Complex(math.cos(phi + lambda), math.sin(phi + lambda))

            var gate_matrix = [
                [math.Complex(cos_half, 0.0), e_ilambda.multiply(math.Complex(-sin_half, 0.0))],
                [e_iphi.multiply(math.Complex(sin_half, 0.0)), e_iphi_lambda.multiply(math.Complex(cos_half, 0.0))]
            ]
            circuit.apply_single_gate(qubit, gate_matrix)
        }

        // Helper to create identity matrix of given size
        func create_identity_matrix(size: Int) -> List[List[math.Complex]] {
            var matrix = []
            for i in range(size) {
                var row = []
                for j in range(size) {
                    if i == j {
                        row.append(math.Complex(1.0, 0.0))
                    } else {
                        row.append(math.Complex(0.0, 0.0))
                    }
                }
                matrix.append(row)
            }
            return matrix
        }
    }
}