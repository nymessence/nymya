// Math Library Entry Point
// Exposes all mathematical functions and types from the math library

// Re-export important math types
export class BigInt {
    private internal_value: crystal.Pointer

    init(value: Int) { /* implementation */ }
    init(value: String) { /* implementation */ }
    func add(other: BigInt) -> BigInt { /* implementation */ }
    func subtract(other: BigInt) -> BigInt { /* implementation */ }
    func multiply(other: BigInt) -> BigInt { /* implementation */ }
    func divide(other: BigInt) -> BigInt { /* implementation */ }
    func mod(other: BigInt) -> BigInt { /* implementation */ }
    func pow(exp: Int) -> BigInt { /* implementation */ }
    func gcd(other: BigInt) -> BigInt { /* implementation */ }
    func to_string() -> String { /* implementation */ }
    func to_int() -> Int { /* implementation */ }
    func dispose() -> Void { /* implementation */ }
}

export struct Complex {
    real: Float
    imag: Float
    init(real: Float, imag: Float) { /* implementation */ }
    func magnitude() -> Float { /* implementation */ }
    func phase() -> Float { /* implementation */ }
    func conjugate() -> Complex { /* implementation */ }
    func add(other: Complex) -> Complex { /* implementation */ }
    func subtract(other: Complex) -> Complex { /* implementation */ }
    func multiply(other: Complex) -> Complex { /* implementation */ }
    func divide(other: Complex) -> Complex { /* implementation */ }
    func power(exp: Float) -> Complex { /* implementation */ }
}

// Re-export vector-related classes
export namespace vector {
    export class Vec2 {
        x: Float
        y: Float
        init(x: Float, y: Float) { /* implementation */ }
        func magnitude() -> Float { /* implementation */ }
        func magnitude_squared() -> Float { /* implementation */ }
        func normalize() -> Vec2 { /* implementation */ }
        func dot(other: Vec2) -> Float { /* implementation */ }
        func cross(other: Vec2) -> Float { /* implementation */ }
        func distance_to(other: Vec2) -> Float { /* implementation */ }
        func angle_to(other: Vec2) -> Float { /* implementation */ }
        func add(other: Vec2) -> Vec2 { /* implementation */ }
        func subtract(other: Vec2) -> Vec2 { /* implementation */ }
        func multiply(scalar: Float) -> Vec2 { /* implementation */ }
        func rotate(angle: Float) -> Vec2 { /* implementation */ }
    }

    export class Vec3 {
        x: Float
        y: Float
        z: Float
        init(x: Float, y: Float, z: Float) { /* implementation */ }
        func magnitude() -> Float { /* implementation */ }
        func magnitude_squared() -> Float { /* implementation */ }
        func normalize() -> Vec3 { /* implementation */ }
        func dot(other: Vec3) -> Float { /* implementation */ }
        func cross(other: Vec3) -> Vec3 { /* implementation */ }
        func distance_to(other: Vec3) -> Float { /* implementation */ }
        func add(other: Vec3) -> Vec3 { /* implementation */ }
        func subtract(other: Vec3) -> Vec3 { /* implementation */ }
        func multiply(scalar: Float) -> Vec3 { /* implementation */ }
        func angle_to(other: Vec3) -> Float { /* implementation */ }
    }

    export class Vec4 {
        x: Float
        y: Float
        z: Float
        w: Float
        init(x: Float, y: Float, z: Float, w: Float) { /* implementation */ }
        func magnitude() -> Float { /* implementation */ }
        func normalize() -> Vec4 { /* implementation */ }
        func dot(other: Vec4) -> Float { /* implementation */ }
        func add(other: Vec4) -> Vec4 { /* implementation */ }
        func subtract(other: Vec4) -> Vec4 { /* implementation */ }
    }
}

// Re-export matrix-related classes
export namespace matrix {
    export class Matrix2x2 {
        data: List[List[Float]]
        init() { /* implementation */ }
        init(values: List[List[Float]]) { /* implementation */ }
        func multiply_vector(vec: vector.Vec2) -> vector.Vec2 { /* implementation */ }
        func multiply(other: Matrix2x2) -> Matrix2x2 { /* implementation */ }
        func determinant() -> Float { /* implementation */ }
        func transpose() -> Matrix2x2 { /* implementation */ }
    }

    export class Matrix3x3 {
        data: List[List[Float]]
        init() { /* implementation */ }
        init(values: List[List[Float]]) { /* implementation */ }
        func multiply_vector(vec: vector.Vec3) -> vector.Vec3 { /* implementation */ }
        func multiply(other: Matrix3x3) -> Matrix3x3 { /* implementation */ }
        func determinant() -> Float { /* implementation */ }
        func transpose() -> Matrix3x3 { /* implementation */ }
    }

    export class Matrix4x4 {
        data: List[List[Float]]
        init() { /* implementation */ }
        init(values: List[List[Float]]) { /* implementation */ }
        func multiply_vector(vec: vector.Vec4) -> vector.Vec4 { /* implementation */ }
        func multiply(other: Matrix4x4) -> Matrix4x4 { /* implementation */ }
        func transpose() -> Matrix4x4 { /* implementation */ }
    }
}

// Re-export advanced math functions
export namespace advanced {
    export namespace statistics {
        export func mean(values: List[Float]) -> Float { /* implementation */ }
        export func variance(values: List[Float]) -> Float { /* implementation */ }
        export func std_dev(values: List[Float]) -> Float { /* implementation */ }
        export func median(values: List[Float]) -> Float { /* implementation */ }
    }

    export namespace interpolation {
        export func linear(x0: Float, y0: Float, x1: Float, y1: Float, x: Float) -> Float { /* implementation */ }
        export func lerp(start: Float, end: Float, t: Float) -> Float { /* implementation */ }
        export func smoothstep(edge0: Float, edge1: Float, x: Float) -> Float { /* implementation */ }
    }

    export namespace polynomial {
        export func quadratic(a: Float, b: Float, c: Float, x: Float) -> Float { /* implementation */ }
        export func cubic(a: Float, b: Float, c: Float, d: Float, x: Float) -> Float { /* implementation */ }
        export func evaluate_coefficients(coeffs: List[Float], x: Float) -> Float { /* implementation */ }
    }

    export func gamma(x: Float) -> Float { /* implementation */ }
    export func lgamma(x: Float) -> Float { /* implementation */ }
    export func erf(x: Float) -> Float { /* implementation */ }
    export func erfc(x: Float) -> Float { /* implementation */ }
}

// Re-export basic math functions
export func abs(x: Float) -> Float { /* implementation */ }
export func abs_int(x: Int) -> Int { /* implementation */ }
export func min(a: Float, b: Float) -> Float { /* implementation */ }
export func max(a: Float, b: Float) -> Float { /* implementation */ }
export func min_int(a: Int, b: Int) -> Int { /* implementation */ }
export func max_int(a: Int, b: Int) -> Int { /* implementation */ }
export func clamp(value: Float, min_val: Float, max_val: Float) -> Float { /* implementation */ }
export func sign(x: Float) -> Float { /* implementation */ }
export func sin(x: Float) -> Float { /* implementation */ }
export func cos(x: Float) -> Float { /* implementation */ }
export func tan(x: Float) -> Float { /* implementation */ }
export func asin(x: Float) -> Float { /* implementation */ }
export func acos(x: Float) -> Float { /* implementation */ }
export func atan(x: Float) -> Float { /* implementation */ }
export func atan2(y: Float, x: Float) -> Float { /* implementation */ }
export func sinh(x: Float) -> Float { /* implementation */ }
export func cosh(x: Float) -> Float { /* implementation */ }
export func tanh(x: Float) -> Float { /* implementation */ }
export func asinh(x: Float) -> Float { /* implementation */ }
export func acosh(x: Float) -> Float { /* implementation */ }
export func atanh(x: Float) -> Float { /* implementation */ }
export func sqrt(x: Float) -> Float { /* implementation */ }
export func cbrt(x: Float) -> Float { /* implementation */ }
export func pow(base: Float, exp: Float) -> Float { /* implementation */ }
export func exp(x: Float) -> Float { /* implementation */ }
export func exp2(x: Float) -> Float { /* implementation */ }
export func log(x: Float) -> Float { /* implementation */ }
export func log2(x: Float) -> Float { /* implementation */ }
export func log10(x: Float) -> Float { /* implementation */ }
export func log1p(x: Float) -> Float { /* implementation */ }
export func ceil(x: Float) -> Float { /* implementation */ }
export func floor(x: Float) -> Float { /* implementation */ }
export func round(x: Float) -> Float { /* implementation */ }
export func trunc(x: Float) -> Float { /* implementation */ }

// Re-export constants
export val PI: Float = 3.141592653589793
export val E: Float = 2.718281828459045
export val TAU: Float = 6.283185307179586
export val PHI: Float = 1.618033988749895
export val SQRT2: Float = 1.4142135623730951
export val SQRT3: Float = 1.7320508075688772
export val INV_SQRT2: Float = 0.7071067811865476

// Re-export GMP namespace
export namespace gmp {
    // Re-exported from math.gmp
}