// AI/ML and Quantum ML Test Suite
// Testing both classical ML and quantum ML capabilities

import ml
import ml.classical
import ml.quantum_ml
import ml.training_utils
import math
import crystal

func test_classical_ml_tensors() -> Void {
    crystal.manifest("=== Testing Classical ML - Tensors ===")
    
    // Test tensor creation
    var tensor1 = ml.classical.Tensor(2, 3)
    tensor1.set_value(0, 0, 1.0)
    tensor1.set_value(0, 1, 2.0)
    tensor1.set_value(1, 0, 3.0)
    tensor1.set_value(1, 1, 4.0)
    
    crystal.manifest("Tensor 1 shape: " + tensor1.get_shape())
    tensor1.print_tensor()
    
    // Test second tensor
    var tensor2 = ml.classical.Tensor(3, 2)
    tensor2.set_value(0, 0, 1.0)
    tensor2.set_value(0, 1, 2.0)
    tensor2.set_value(1, 0, 3.0)
    tensor2.set_value(1, 1, 4.0)
    tensor2.set_value(2, 0, 5.0)
    tensor2.set_value(2, 1, 6.0)
    
    crystal.manifest("Tensor 2 shape: " + tensor2.get_shape())
    tensor2.print_tensor()
    
    // Test tensor multiplication
    var result_mult = tensor1.multiply(tensor2)
    crystal.manifest("Multiplication result shape: " + result_mult.get_shape())
    result_mult.print_tensor()
    
    // Test tensor addition
    var tensor3 = ml.classical.Tensor(2, 3)
    tensor3.set_value(0, 0, 1.0)
    tensor3.set_value(0, 1, 1.0)
    tensor3.set_value(1, 0, 1.0) 
    tensor3.set_value(1, 1, 1.0)
    
    var result_add = tensor1.add(tensor3)
    crystal.manifest("Addition result shape: " + result_add.get_shape())
    result_add.print_tensor()
    
    // Test scalar multiplication
    var scaled = tensor1.scalar_multiply(2.0)
    crystal.manifest("Scaled tensor shape: " + scaled.get_shape())
    scaled.print_tensor()
    
    // Test transpose
    var transposed = tensor1.transpose()
    crystal.manifest("Transposed tensor shape: " + transposed.get_shape())
    transposed.print_tensor()
    
    // Test activation function
    var activated = tensor1.apply_activation("relu")
    crystal.manifest("ReLU activated tensor:")
    activated.print_tensor()
    
    crystal.manifest("Tensor operations test completed!")
}

func test_neural_network() -> Void {
    crystal.manifest("=== Testing Neural Network ===")
    
    // Create neural network
    var nn = ml.classical.NeuralNetwork()
    
    // Add layers: 3 inputs -> 4 hidden -> 2 outputs
    var layer1 = ml.classical.Layer(3, 4, "relu")
    var layer2 = ml.classical.Layer(4, 2, "sigmoid")
    
    nn.add_layer(layer1)
    nn.add_layer(layer2)
    
    crystal.manifest("Neural network created with " + nn.get_num_layers() + " layers")
    
    // Test forward pass
    var input_tensor = ml.classical.Tensor(1, 3)
    input_tensor.set_value(0, 0, 0.5)
    input_tensor.set_value(0, 1, 0.3)
    input_tensor.set_value(0, 2, 0.8)
    
    var output = nn.predict(input_tensor)
    crystal.manifest("Input: (" + input_tensor.get_value(0, 0) + ", " + 
                                input_tensor.get_value(0, 1) + ", " + 
                                input_tensor.get_value(0, 2) + ")")
    crystal.manifest("Output: (" + output.get_value(0, 0) + ", " + 
                                 output.get_value(0, 1) + ")")
    
    crystal.manifest("Neural network test completed!")
}

func test_loss_functions() -> Void {
    crystal.manifest("=== Testing Loss Functions ===")
    
    // Test MSE
    var predictions = [0.8, 0.2, 0.6]
    var targets = [1.0, 0.0, 0.5]
    
    var mse_loss = ml.classical.mean_squared_error(predictions, targets)
    crystal.manifest("MSE Loss: " + mse_loss)
    
    // Test Cross-Entropy
    var ce_loss = ml.classical.cross_entropy_loss(predictions, targets)
    crystal.manifest("Cross-Entropy Loss: " + ce_loss)
    
    crystal.manifest("Loss functions test completed!")
}

func test_quantum_ml() -> Void {
    crystal.manifest("=== Testing Quantum ML ===")
    
    // Test Parameterized Quantum Circuit
    var pqc = ml.quantum_ml.ParameterizedCircuit(3)  // 3 qubits
    crystal.manifest("Parameterized Quantum Circuit created with " + pqc.num_qubits + " qubits")
    
    // Get initial parameters
    var params = pqc.get_parameters()
    crystal.manifest("Initial parameters count: " + params.length)
    
    // Apply circuit
    var measurements = pqc.measure_all()
    crystal.manifest("Measurement outcomes: " + measurements.join(", "))
    
    // Test state vector
    var statevector = pqc.get_statevector()
    crystal.manifest("Statevector length: " + statevector.length)
    
    crystal.manifest("PQC test completed!")
}

func test_quantum_variational_classifier() -> Void {
    crystal.manifest("=== Testing Quantum Variational Classifier ===")
    
    // Create classifier: 3 qubits, 2 classes
    var qvc = ml.quantum_ml.VariationalClassifier(3, 2)
    crystal.manifest("Quantum Variational Classifier created")
    crystal.manifest("Number of weights: " + qvc.get_weights().length)
    
    // Test prediction
    var input_data = [0.5, 0.3, 0.8]
    var outputs = qvc.forward(input_data)
    crystal.manifest("Forward pass outputs: " + outputs.join(", "))
    
    var prediction = qvc.predict(input_data)
    crystal.manifest("Prediction class: " + prediction)
    
    crystal.manifest("Quantum Variational Classifier test completed!")
}

func test_quantum_neural_layer() -> Void {
    crystal.manifest("=== Testing Quantum Neural Layer ===")
    
    // Create quantum neural layer
    var q_layer = ml.quantum_ml.QuantumNeuralLayer(3)  // 3-qubit layer
    crystal.manifest("Quantum Neural Layer created with 3 qubits")
    
    // Forward pass with inputs
    var inputs = [0.7, 0.4, 0.9]
    var outputs = q_layer.forward(inputs)
    crystal.manifest("Inputs: " + inputs.join(", "))
    crystal.manifest("Outputs: " + outputs.join(", "))
    
    crystal.manifest("Quantum Neural Layer test completed!")
}

func test_training_simulation() -> Void {
    crystal.manifest("=== Testing Classical ML Training Simulation ===")
    
    // Create neural network for simulation
    var nn = ml.classical.NeuralNetwork()
    nn.add_layer(ml.classical.Layer(2, 4, "relu"))  // 2 inputs -> 4 hidden
    nn.add_layer(ml.classical.Layer(4, 1, "sigmoid"))  // 4 hidden -> 1 output
    
    // Generate sample data
    var inputs = []
    var targets = []
    
    // Create XOR-like dataset: inputs should produce opposite output when they're the same
    var input1 = ml.classical.Tensor(1, 2)
    input1.set_value(0, 0, 0.0)
    input1.set_value(0, 1, 0.0) 
    inputs.append(input1)
    
    var target1 = ml.classical.Tensor(1, 1)
    target1.set_value(0, 0, 0.0)  // XOR(0,0) = 0
    targets.append(target1)
    
    var input2 = ml.classical.Tensor(1, 2)
    input2.set_value(0, 0, 0.0)
    input2.set_value(0, 1, 1.0)
    inputs.append(input2)
    
    var target2 = ml.classical.Tensor(1, 1)
    target2.set_value(0, 0, 1.0)  // XOR(0,1) = 1
    targets.append(target2)
    
    var input3 = ml.classical.Tensor(1, 2)
    input3.set_value(0, 0, 1.0)
    input3.set_value(0, 1, 0.0)
    inputs.append(input3)
    
    var target3 = ml.classical.Tensor(1, 1)
    target3.set_value(0, 0, 1.0)  // XOR(1,0) = 1
    targets.append(target3)
    
    var input4 = ml.classical.Tensor(1, 2)
    input4.set_value(0, 0, 1.0)
    input4.set_value(0, 1, 1.0)
    inputs.append(input4)
    
    var target4 = ml.classical.Tensor(1, 1)
    target4.set_value(0, 0, 0.0)  // XOR(1,1) = 0
    targets.append(target4)
    
    // Test prediction before training
    crystal.manifest("Predictions before training:")
    for i in range(inputs.length) {
        var pred = nn.predict(inputs[i])
        var expected = targets[i].get_value(0, 0)
        crystal.manifest("  Input: (" + inputs[i].get_value(0, 0) + "," + inputs[i].get_value(0, 1) + 
                         ") -> Pred: " + pred.get_value(0, 0) + ", Expected: " + expected)
    }
    
    // Run training simulation
    ml.classical.simulate_training(nn, inputs, targets, 100)
    
    // Test prediction after training simulation
    crystal.manifest("Predictions after training simulation:")
    for i in range(inputs.length) {
        var pred = nn.predict(inputs[i])
        var expected = targets[i].get_value(0, 0)
        crystal.manifest("  Input: (" + inputs[i].get_value(0, 0) + "," + inputs[i].get_value(0, 1) + 
                         ") -> Pred: " + pred.get_value(0, 0) + ", Expected: " + expected)
    }
    
    crystal.manifest("Training simulation test completed!")
}

func test_data_utils() -> Void {
    crystal.manifest("=== Testing Data Utilities ===")
    
    // Generate dataset
    var dataset = ml.training_utils.generate_simple_dataset(10)
    crystal.manifest("Generated dataset with " + dataset.length + " samples")
    
    for i in range(math.min(3, dataset.length)) {
        crystal.manifest("  Sample " + i + ": " + dataset[i].join(", "))
    }
    
    // Generate labels
    var labels = ml.training_utils.generate_labels(dataset)
    crystal.manifest("Generated " + labels.length + " labels")
    
    for i in range(math.min(3, labels.length)) {
        crystal.manifest("  Label " + i + ": " + labels[i])
    }
    
    // Test normalization
    var normalized = ml.training_utils.normalize_data(dataset)
    crystal.manifest("Normalized data (first 3 samples):")
    for i in range(math.min(3, normalized.length)) {
        crystal.manifest("  Normalized " + i + ": " + normalized[i].join(", "))
    }
    
    // Test accuracy calculation
    var predictions = [0, 1, 1, 0, 1]
    var true_labels = [0, 1, 0, 0, 1]  // Last one is wrong
    var accuracy = ml.training_utils.calculate_accuracy(predictions, true_labels)
    crystal.manifest("Accuracy: " + accuracy + "% (4/5 or 80%)")
    
    crystal.manifest("Data utilities test completed!")
}

func test_quantum_svm() -> Void {
    crystal.manifest("=== Testing Quantum SVM ===")
    
    // Create quantum SVM
    var qsvm = ml.quantum_ml.QuantumSVM(2)  // 2-dimensional feature space
    crystal.manifest("Quantum SVM created for 2D feature space")
    
    // Create training data (simplified)
    var training_data = [
        [0.1, 0.2],
        [0.2, 0.3],
        [0.8, 0.9],
        [0.9, 0.8]
    ]
    var labels = [0, 0, 1, 1]  // First two class 0, last two class 1
    
    qsvm.fit(training_data, labels)
    
    // Test prediction
    var test_point = [0.15, 0.25]
    var prediction = qsvm.predict_single(test_point)
    crystal.manifest("Predicted class for [" + test_point.join(", ") + "]: " + prediction)
    
    var test_point2 = [0.85, 0.85]
    var prediction2 = qsvm.predict_single(test_point2)
    crystal.manifest("Predicted class for [" + test_point2.join(", ") + "]: " + prediction2)
    
    crystal.manifest("Quantum SVM test completed!")
}

func main() -> Void {
    test_classical_ml_tensors()
    crystal.manifest("")
    
    test_neural_network() 
    crystal.manifest("")
    
    test_loss_functions()
    crystal.manifest("")
    
    test_quantum_ml()
    crystal.manifest("")
    
    test_quantum_variational_classifier()
    crystal.manifest("")
    
    test_quantum_neural_layer()
    crystal.manifest("")
    
    test_training_simulation()
    crystal.manifest("")
    
    test_data_utils()
    crystal.manifest("")
    
    test_quantum_svm()
    crystal.manifest("")
    
    crystal.manifest("=== ALL AI/ML AND QML TESTS COMPLETED SUCCESSFULLY! ===")
}