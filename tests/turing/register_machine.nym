// Turing Completeness Verification: Simple Register Machine
// Demonstrates register-based computation capabilities of NymyaLang

import math
import crystal
import lowlevel

namespace turing_register {

    // Register machine with 8 general-purpose registers
    class RegisterMachine {
        registers: List[Int]
        program_counter: Int
        halted: Bool
        
        init() {
            this.registers = []
            for i in range(8) {  // 8 registers: R0-R7
                this.registers.append(0)
            }
            this.program_counter = 0
            this.halted = false
        }
        
        func get_register(index: Int) -> Int {
            if index >= 0 and index < this.registers.length {
                return this.registers[index]
            }
            return 0
        }
        
        func set_register(index: Int, value: Int) -> Void {
            if index >= 0 and index < this.registers.length {
                this.registers[index] = value
            }
        }
        
        func load_immediate(reg_index: Int, value: Int) -> Void {
            this.set_register(reg_index, value)
        }
        
        func add(reg_dest: Int, reg_src1: Int, reg_src2: Int) -> Void {
            var result = this.get_register(reg_src1) + this.get_register(reg_src2)
            this.set_register(reg_dest, result)
        }
        
        func subtract(reg_dest: Int, reg_src1: Int, reg_src2: Int) -> Void {
            var result = this.get_register(reg_src1) - this.get_register(reg_src2)
            this.set_register(reg_dest, result)
        }
        
        func multiply(reg_dest: Int, reg_src1: Int, reg_src2: Int) -> Void {
            var result = this.get_register(reg_src1) * this.get_register(reg_src2)
            this.set_register(reg_dest, result)
        }
        
        func compare(reg1: Int, reg2: Int) -> Int {
            var val1 = this.get_register(reg1)
            var val2 = this.get_register(reg2)
            
            if val1 > val2 {
                return 1
            } else if val1 < val2 {
                return -1
            } else {
                return 0
            }
        }
        
        func jump(address: Int) -> Void {
            this.program_counter = address
        }
        
        func conditional_jump(condition: Int, address: Int) -> Void {
            // condition: 0=jump if zero, 1=jump if positive, -1=jump if negative
            var comparison_result = this.compare(0, 1)  // Compare R0 and R1
            if (condition == 0 and comparison_result == 0) or
               (condition == 1 and comparison_result > 0) or
               (condition == -1 and comparison_result < 0) {
                this.jump(address)
            }
        }
        
        func halt() -> Void {
            this.halted = true
        }
        
        func is_halted() -> Bool {
            return this.halted
        }
        
        func get_program_counter() -> Int {
            return this.program_counter
        }
        
        func to_string() -> String {
            var result = "Registers: "
            for i in range(this.registers.length) {
                if i > 0 {
                    result = result + ", "
                }
                result = result + "R" + i + ":" + this.registers[i]
            }
            result = result + " | PC: " + this.program_counter + " | Halted: " + this.halted
            return result
        }
    }

    // Simple program: Calculate 5 + 3
    func test_simple_arithmetic() -> Int {
        var machine = RegisterMachine()
        
        // Load 5 into R0
        machine.load_immediate(0, 5)
        // Load 3 into R1
        machine.load_immediate(1, 3)
        // Add R0 and R1, store result in R2
        machine.add(2, 0, 1)
        
        // Return the result from R2
        return machine.get_register(2)
    }

    // Program to calculate factorial of a number using the register machine
    func calculate_factorial(machine: RegisterMachine, n: Int) -> Int {
        // R0 = n (input)
        // R1 = counter
        // R2 = result
        // R3 = temporary
        
        machine.load_immediate(0, n)  // Input n
        machine.load_immediate(1, 1)  // Counter starts at 1
        machine.load_immediate(2, 1)  // Result starts at 1
        
        // Loop: while counter <= n
        var loop_start = machine.get_program_counter()
        
        // Compare counter (R1) with n (R0)
        var cmp_result = machine.compare(1, 0)  // R1 - R0
        
        // If counter > n, we're done
        if cmp_result > 0 {
            // Factorial is in R2
            return machine.get_register(2)
        }
        
        // Multiply result by counter: R2 = R2 * R1
        machine.multiply(2, 2, 1)
        
        // Increment counter: R1 = R1 + 1
        machine.load_immediate(3, 1)
        machine.add(1, 1, 3)
        
        // Jump back to loop start (this is a simplified version without actual jumps)
        // In a real register machine, we'd use conditional jumps
        
        // For this test, we'll just do a bounded loop
        if machine.get_register(1) <= n {
            // Continue the loop by recalculating
            return calculate_factorial(machine, n)  // Recursive call to simulate loop
        }
        
        return machine.get_register(2)
    }

    // Fibonacci calculation using register machine concepts
    func register_fibonacci(n: Int) -> Int {
        if n <= 1 {
            return n
        }
        
        var machine = RegisterMachine()
        
        // R0 = n
        // R1 = current fibonacci number
        // R2 = previous fibonacci number
        // R3 = counter
        // R4 = temporary storage
        
        machine.load_immediate(0, n)
        machine.load_immediate(1, 1)  // fib(1) = 1
        machine.load_immediate(2, 0)  // fib(0) = 0
        machine.load_immediate(3, 2)  // start counter at 2
        
        for i in range(2, n + 1) {
            // Calculate fib(i) = fib(i-1) + fib(i-2)
            machine.add(4, 1, 2)  // R4 = R1 + R2 (next fib number)
            
            // Update: previous becomes current, current becomes next
            machine.set_register(2, machine.get_register(1))  // R2 = R1
            machine.set_register(1, machine.get_register(4))  // R1 = R4
            machine.load_immediate(4, 1)
            machine.add(3, 3, 4)  // increment counter
        }
        
        return machine.get_register(1)  // Return the nth fibonacci
    }

    // Run the tests
    func run_tests() -> Void {
        crystal.manifest("=== Register Machine Test ===")
        
        // Test simple arithmetic
        var result1 = test_simple_arithmetic()
        crystal.manifest("5 + 3 = " + result1)
        
        // Test factorial calculation (small number to avoid recursion issues)
        var machine = RegisterMachine()
        var result2 = calculate_factorial(machine, 4)
        crystal.manifest("4! = " + result2)
        
        // Test fibonacci
        var result3 = register_fibonacci(6)
        crystal.manifest("fibonacci(6) = " + result3)
        
        crystal.manifest("Register machine test completed successfully!")
    }
}

// Entry point
turing_register.run_tests()