// Turing Completeness Verification: Unbounded Looping Example
// Demonstrates NymyaLang's ability to perform unbounded computation

import crystal
import math

namespace turing.looping {

    // Simple counter loop (demonstrates basic unbounded counting)
    func simple_counter(max_count: Int) -> Int {
        var count = 0
        while count < max_count {
            count = count + 1
        }
        return count
    }

    // Recursive factorial function (demonstrates unbounded recursion)
    func recursive_factorial(n: Int) -> Int {
        if n <= 1 {
            return 1
        } else {
            return n * recursive_factorial(n - 1)
        }
    }

    // Recursive fibonacci (demonstrates exponential recursion)
    func recursive_fibonacci(n: Int) -> Int {
        if n <= 1 {
            return n
        } else {
            return recursive_fibonacci(n - 1) + recursive_fibonacci(n - 2)
        }
    }

    // Dynamic termination loop (unbounded until condition is met)
    func dynamic_termination(start_value: Int, target: Int) -> Int {
        var current = start_value
        var iterations = 0
        var max_iterations = 10000  // Prevent infinite loops in test
        
        while current != target and iterations < max_iterations {
            if current < target {
                current = current + 1
            } else {
                current = current - 1
            }
            iterations = iterations + 1
        }
        
        return current
    }

    // Count down to zero recursively
    func countdown_recursive(n: Int) -> Int {
        crystal.manifest("Countdown: " + n)
        if n <= 0 {
            crystal.manifest("Blast off!")
            return 0
        } else {
            return 1 + countdown_recursive(n - 1)
        }
    }

    // Collatz conjecture sequence (famous unbounded computation example)
    func collatz_sequence(n: Int) -> Int {
        var current = n
        var steps = 0
        var max_steps = 1000  // Prevent infinite loops for testing
        
        while current != 1 and steps < max_steps {
            if current % 2 == 0 {
                current = current / 2
            } else {
                current = 3 * current + 1
            }
            steps = steps + 1
        }
        
        return steps
    }

    // Run the tests
    func run_tests() -> Void {
        crystal.manifest("=== Unbounded Looping/Recursion Test ===")
        
        // Test simple loop
        var loop_result = simple_counter(100)
        crystal.manifest("simple_counter(100) = " + loop_result)
        
        // Test factorial recursion
        var fact_result = recursive_factorial(10)
        crystal.manifest("10! = " + fact_result)
        
        // Test fibonacci recursion (small number to avoid long computation)
        var fib_result = recursive_fibonacci(10)
        crystal.manifest("fibonacci(10) = " + fib_result)
        
        // Test dynamic loop
        var dynamic_result = dynamic_termination(50, 60)
        crystal.manifest("Dynamic termination: " + dynamic_result)
        
        // Test recursive countdown
        crystal.manifest("Starting countdown...")
        var countdown_result = countdown_recursive(5)
        crystal.manifest("Countdown returned: " + countdown_result)
        
        // Test Collatz sequence
        var collatz_steps = collatz_sequence(7)
        crystal.manifest("Steps for Collatz sequence starting at 7: " + collatz_steps)
        
        crystal.manifest("Unbounded looping/recursion test completed successfully!")
    }
}

turing.looping.run_tests()