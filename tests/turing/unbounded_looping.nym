// Test 2: Unbounded Looping/Recursion
// This demonstrates the unbounded computation capability required for Turing completeness

import crystal
import math

namespace turing.unbounded {

    // Test unbounded loops with dynamic termination
    func test_loops() -> Void {
        crystal.manifest("=== Unbounded Looping Test ===")
        
        // Simple counter loop (bounded in test but unbounded in principle)
        var counter = 0
        while counter < 10 {
            crystal.manifest("Counter: " + counter)
            counter = counter + 1
        }
        crystal.manifest("Loop completed after " + counter + " iterations")
        
        // Simulate dynamic termination loop (unknown beforehand)
        var target = 25
        var current = 1
        var steps = 0
        var max_steps = 100  // Safety limit for test
        while current != target and steps < max_steps {
            if current < target {
                current = current + 1
            } else {
                current = current - 1
            }
            steps = steps + 1
        }
        crystal.manifest("Dynamic termination reached target " + target + " in " + steps + " steps")
        
        crystal.manifest("=== Unbounded Looping Test Complete ===\n")
    }

    // Test unbounded recursion
    func test_recursion() -> Void {
        crystal.manifest("=== Unbounded Recursion Test ===")
        
        // Factorial function - demonstrates unbounded recursion depth
        func factorial(n: Int) -> Int {
            if n <= 1 {
                return 1
            } else {
                return n * factorial(n - 1)
            }
        }
        
        var fact_5 = factorial(5)
        crystal.manifest("Factorial of 5: " + fact_5)
        
        // Fibonacci with recursion - also demonstrates branching recursion
        func fibonacci(n: Int) -> Int {
            if n <= 1 {
                return n
            } else {
                return fibonacci(n - 1) + fibonacci(n - 2)
            }
        }
        
        var fib_10 = fibonacci(10)
        crystal.manifest("Fibonacci of 10: " + fib_10)
        
        // Countdown function - simple recursion that terminates based on input
        func countdown(n: Int) -> Void {
            if n <= 0 {
                crystal.manifest("Blast off!")
            } else {
                crystal.manifest("Countdown: " + n)
                countdown(n - 1)
            }
        }
        
        crystal.manifest("Starting countdown:")
        countdown(3)
        
        crystal.manifest("=== Unbounded Recursion Test Complete ===\n")
    }

    func run_tests() -> Void {
        test_loops()
        test_recursion()
    }
}

turing.unbounded.run_tests()