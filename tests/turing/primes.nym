// Nontrivial Computation Test - Prime Number Generation
// Demonstrates NymyaLang's ability to perform complex computations

import crystal

namespace turing.primes {

    // Simple prime number generator using trial division
    func generate_primes(count: Int) -> List[Int] {
        var primes = []
        var candidate = 2  // Start with first prime
        
        while primes.length < count {
            if is_prime(candidate) {
                primes.append(candidate)
            }
            candidate = candidate + 1
        }
        
        return primes
    }
    
    // Prime checker using trial division
    func is_prime(n: Int) -> Bool {
        if n <= 1 {
            return false
        }
        if n <= 3 {
            return true
        }
        if n % 2 == 0 or n % 3 == 0 {
            return false
        }
        
        // Check divisibility by numbers of form 6k ± 1 up to √n
        var i = 5
        while i * i <= n {
            if n % i == 0 or n % (i + 2) == 0 {
                return false
            }
            i = i + 6
        }
        
        return true
    }
    
    // Sieve of Eratosthenes implementation
    func sieve_of_eratosthenes(limit: Int) -> List[Int] {
        if limit < 2 {
            return []
        }
        
        // Create a boolean list "is_prime[0..limit]" and initialize all entries as true
        var is_prime = []
        for i in range(limit + 1) {
            if i < 2 {
                is_prime.append(false)
            } else {
                is_prime.append(true)
            }
        }
        
        var p = 2
        while p * p <= limit {
            // If is_prime[p] is not changed, then it's a prime
            if is_prime[p] {
                // Mark all multiples of p starting from p*p
                var i = p * p
                while i <= limit {
                    is_prime[i] = false
                    i = i + p
                }
            }
            p = p + 1
        }
        
        // Collect all prime numbers
        var primes = []
        for i in range(2, limit + 1) {
            if is_prime[i] {
                primes.append(i)
            }
        }
        
        return primes
    }
    
    // Factorial computation (demonstrates recursion and large number handling)
    func factorial(n: Int) -> Int {
        if n <= 1 {
            return 1
        }
        return n * factorial(n - 1)
    }
    
    // Fibonacci computation (demonstrates recursion and exponential growth)
    func fibonacci(n: Int) -> Int {
        if n <= 1 {
            return n
        }
        return fibonacci(n - 1) + fibonacci(n - 2)
    }
    
    // Memoized Fibonacci for better performance
    class FibonacciCalculator {
        cache: List[Int]
        
        init() {
            this.cache = []
            // Pre-populate with base cases
            this.cache.append(0)  // fib(0) = 0
            this.cache.append(1)  // fib(1) = 1
        }
        
        func get(n: Int) -> Int {
            if n < this.cache.length {
                return this.cache[n]
            }
            
            // Extend cache if needed
            for i in range(this.cache.length, n + 1) {
                var val = this.get(i - 1) + this.get(i - 2)
                this.cache.append(val)
            }
            
            return this.cache[n]
        }
    }
    
    func run_computation_tests() -> Void {
        crystal.manifest("=== Nontrivial Computation Tests ===")
        
        // Test prime generation
        crystal.manifest("--- Prime Number Generation ---")
        var primes = generate_primes(10)
        crystal.manifest("First 10 primes: " + primes.join(", "))

        // Test sieve of Eratosthenes
        var sieve_primes = sieve_of_eratosthenes(50)
        crystal.manifest("Primes up to 50: " + sieve_primes.join(", "))
        
        // Test factorial computation
        crystal.manifest("--- Factorial Computations ---")
        for i in range(1, 8) {
            var fact = factorial(i)
            crystal.manifest(i + "! = " + fact)
        }
        
        // Test Fibonacci computation
        crystal.manifest("--- Fibonacci Numbers ---")
        var fib_calc = FibonacciCalculator()
        for i in range(10) {
            var fib_val = fib_calc.get(i)
            crystal.manifest("Fib(" + i + ") = " + fib_val)
        }
        
        // Test with larger Fibonacci using memoization
        var large_fib = fib_calc.get(20)
        crystal.manifest("Fib(20) = " + large_fib)
        
        // Test prime checking for larger numbers
        crystal.manifest("--- Large Prime Checks ---")
        var test_numbers = [97, 101, 103, 107, 109, 113, 997, 1009, 1013, 1019, 1021]
        for num in test_numbers {
            var is_num_prime = is_prime(num)
            crystal.manifest(num + " is prime: " + is_num_prime)
        }
        
        crystal.manifest("Nontrivial computation tests completed successfully")
    }
}