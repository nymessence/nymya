// Comprehensive Utility Functions Test Suite
// Extensive testing of all utility functions for edge cases and bugs

import lowlevel
import lowlevel.utils
import crystal

func test_endian_conversion() -> Void {
    crystal.manifest("Testing endian conversion utilities...")
    
    // Test 32-bit endian swap
    var original = 0x12345678  // Original: 12 34 56 78
    var swapped = lowlevel.utils.swap_endian_32(original)  // Should become 78 56 34 12 = 0x78563412
    var expected = 0x78563412
    if swapped != expected {
        crystal.manifest("ERROR: SWAP_ENDIAN_32(0x" + original.to_string() + ") = 0x" + swapped.to_string() + ", expected 0x" + expected.to_string())
    } else {
        crystal.manifest("✓ 32-bit endian swap: 0x" + original.to_string() + " -> 0x" + swapped.to_string())
    }
    
    // Test 16-bit endian swap
    var original16 = 0xABCD  // Original: AB CD
    var swapped16 = lowlevel.utils.swap_endian_16(original16)  // Should become CD AB = 0xCDAB
    var expected16 = 0xCDAB
    if swapped16 != expected16 {
        crystal.manifest("ERROR: SWAP_ENDIAN_16(0x" + original16.to_string() + ") = 0x" + swapped16.to_string() + ", expected 0x" + expected16.to_string())
    } else {
        crystal.manifest("✓ 16-bit endian swap: 0x" + original16.to_string() + " -> 0x" + swapped16.to_string())
    }
    
    // Test swap of 0
    var zero_swapped = lowlevel.utils.swap_endian_32(0)
    if zero_swapped != 0 {
        crystal.manifest("ERROR: SWAP_ENDIAN_32(0) = " + zero_swapped + ", expected 0")
    } else {
        crystal.manifest("✓ 32-bit endian swap of 0")
    }
    
    // Test swap with symmetric value
    var symmetric = 0x01000001
    swapped = lowlevel.utils.swap_endian_32(symmetric)
    var expected_sym = 0x01000001  // Should be symmetric
    if swapped != expected_sym {
        crystal.manifest("ERROR: SWAP_ENDIAN_32(0x" + symmetric.to_string() + ") = 0x" + swapped.to_string() + ", expected 0x" + expected_sym.to_string())
    } else {
        crystal.manifest("✓ Symmetric endian swap: 0x" + symmetric.to_string() + " -> 0x" + swapped.to_string())
    }
    
    crystal.manifest("Endian conversion utilities tests completed!")
}

func test_alignment_functions() -> Void {
    crystal.manifest("Testing alignment functions...")
    
    // Test align up
    var value = 13
    var aligned = lowlevel.utils.align_up(value, 8)  // Align up to 8-byte boundary
    var expected = 16
    if aligned != expected {
        crystal.manifest("ERROR: ALIGN_UP(13, 8) = " + aligned + ", expected " + expected)
    } else {
        crystal.manifest("✓ Align up: 13 -> 16 (8-byte boundary)")
    }
    
    // Test align up with exact value
    value = 16  // Already aligned
    aligned = lowlevel.utils.align_up(value, 8)
    expected = 16
    if aligned != expected {
        crystal.manifest("ERROR: ALIGN_UP(16, 8) = " + aligned + ", expected " + expected)
    } else {
        crystal.manifest("✓ Align up with exact value: 16 -> 16")
    }
    
    // Test align up with different boundary
    value = 17
    aligned = lowlevel.utils.align_up(value, 16)
    expected = 32
    if aligned != expected {
        crystal.manifest("ERROR: ALIGN_UP(17, 16) = " + aligned + ", expected " + expected)
    } else {
        crystal.manifest("✓ Align up to 16-byte boundary: 17 -> 32")
    }
    
    // Test align down
    value = 20
    aligned = lowlevel.utils.align_down(value, 8)  // Align down to 8-byte boundary
    expected = 16
    if aligned != expected {
        crystal.manifest("ERROR: ALIGN_DOWN(20, 8) = " + aligned + ", expected " + expected)
    } else {
        crystal.manifest("✓ Align down: 20 -> 16 (8-byte boundary)")
    }
    
    // Test align down with exact value
    value = 16  // Already aligned
    aligned = lowlevel.utils.align_down(value, 8)
    expected = 16
    if aligned != expected {
        crystal.manifest("ERROR: ALIGN_DOWN(16, 8) = " + aligned + ", expected " + expected)
    } else {
        crystal.manifest("✓ Align down with exact value: 16 -> 16")
    }
    
    // Test align down with smaller boundary
    value = 17
    aligned = lowlevel.utils.align_down(value, 16)
    expected = 16
    if aligned != expected {
        crystal.manifest("ERROR: ALIGN_DOWN(17, 16) = " + aligned + ", expected " + expected)
    } else {
        crystal.manifest("✓ Align down to 16-byte boundary: 17 -> 16")
    }
    
    // Test with boundary of 1 (no effect)
    value = 15
    aligned = lowlevel.utils.align_up(value, 1)
    if aligned != value {
        crystal.manifest("ERROR: ALIGN_UP(15, 1) = " + aligned + ", expected " + value)
    } else {
        crystal.manifest("✓ Align up with boundary 1: 15 -> 15")
    }
    
    // Test with boundary of power of 2
    aligned = lowlevel.utils.align_up(100, 32)
    expected = 128  // Next multiple of 32 after 100
    if aligned != expected {
        crystal.manifest("ERROR: ALIGN_UP(100, 32) = " + aligned + ", expected " + expected)
    } else {
        crystal.manifest("✓ Align to 32-byte boundary: 100 -> 128")
    }
    
    crystal.manifest("Alignment functions tests completed!")
}

func test_power_of_two_functions() -> Void {
    crystal.manifest("Testing power of two utilities...")
    
    // Test is_power_of_two with powers of two
    var result = lowlevel.utils.is_power_of_two(1)  // 2^0
    if not result {
        crystal.manifest("ERROR: IS_POWER_OF_TWO(1) = false, expected true")
    } else {
        crystal.manifest("✓ Power of two check: 1 is power of two")
    }
    
    result = lowlevel.utils.is_power_of_two(8)  // 2^3
    if not result {
        crystal.manifest("ERROR: IS_POWER_OF_TWO(8) = false, expected true")
    } else {
        crystal.manifest("✓ Power of two check: 8 is power of two")
    }
    
    result = lowlevel.utils.is_power_of_two(16)  // 2^4
    if not result {
        crystal.manifest("ERROR: IS_POWER_OF_TWO(16) = false, expected true")
    } else {
        crystal.manifest("✓ Power of two check: 16 is power of two")
    }
    
    result = lowlevel.utils.is_power_of_two(1024)  // 2^10
    if not result {
        crystal.manifest("ERROR: IS_POWER_OF_TWO(1024) = false, expected true")
    } else {
        crystal.manifest("✓ Power of two check: 1024 is power of two")
    }
    
    // Test is_power_of_two with non-powers of two
    result = lowlevel.utils.is_power_of_two(0)  // Special case: 0 is not a power of two
    if result {
        crystal.manifest("ERROR: IS_POWER_OF_TWO(0) = true, expected false")
    } else {
        crystal.manifest("✓ Power of two check: 0 is not power of two")
    }
    
    result = lowlevel.utils.is_power_of_two(-1)  // Negative values are not powers of two
    if result {
        crystal.manifest("ERROR: IS_POWER_OF_TWO(-1) = true, expected false")
    } else {
        crystal.manifest("✓ Power of two check: -1 is not power of two")
    }
    
    result = lowlevel.utils.is_power_of_two(6)  // Not power of two
    if result {
        crystal.manifest("ERROR: IS_POWER_OF_TWO(6) = true, expected false")
    } else {
        crystal.manifest("✓ Power of two check: 6 is not power of two")
    }
    
    result = lowlevel.utils.is_power_of_two(15)  // Not power of two
    if result {
        crystal.manifest("ERROR: IS_POWER_OF_TWO(15) = true, expected false")
    } else {
        crystal.manifest("✓ Power of two check: 15 is not power of two")
    }
    
    result = lowlevel.utils.is_power_of_two(17)  // Not power of two
    if result {
        crystal.manifest("ERROR: IS_POWER_OF_TWO(17) = true, expected false")
    } else {
        crystal.manifest("✓ Power of two check: 17 is not power of two")
    }
    
    // Test next_power_of_two function
    var next_power = lowlevel.utils.next_power_of_two(1)  // Should be 1
    if next_power != 1 {
        crystal.manifest("ERROR: NEXT_POWER_OF_TWO(1) = " + next_power + ", expected 1")
    } else {
        crystal.manifest("✓ Next power of two: NEXT_POWER_OF_TWO(1) = 1")
    }
    
    next_power = lowlevel.utils.next_power_of_two(2)  // Should be 2
    if next_power != 2 {
        crystal.manifest("ERROR: NEXT_POWER_OF_TWO(2) = " + next_power + ", expected 2")
    } else {
        crystal.manifest("✓ Next power of two: NEXT_POWER_OF_TWO(2) = 2")
    }
    
    next_power = lowlevel.utils.next_power_of_two(3)  // Should be 4
    if next_power != 4 {
        crystal.manifest("ERROR: NEXT_POWER_OF_TWO(3) = " + next_power + ", expected 4")
    } else {
        crystal.manifest("✓ Next power of two: NEXT_POWER_OF_TWO(3) = 4")
    }
    
    next_power = lowlevel.utils.next_power_of_two(10)  // Should be 16
    if next_power != 16 {
        crystal.manifest("ERROR: NEXT_POWER_OF_TWO(10) = " + next_power + ", expected 16")
    } else {
        crystal.manifest("✓ Next power of two: NEXT_POWER_OF_TWO(10) = 16")
    }
    
    next_power = lowlevel.utils.next_power_of_two(16)  // Should be 16 (already power of two)
    if next_power != 16 {
        crystal.manifest("ERROR: NEXT_POWER_OF_TWO(16) = " + next_power + ", expected 16")
    } else {
        crystal.manifest("✓ Next power of two: NEXT_POWER_OF_TWO(16) = 16 (already power)")
    }
    
    next_power = lowlevel.utils.next_power_of_two(17)  // Should be 32
    if next_power != 32 {
        crystal.manifest("ERROR: NEXT_POWER_OF_TWO(17) = " + next_power + ", expected 32")
    } else {
        crystal.manifest("✓ Next power of two: NEXT_POWER_OF_TWO(17) = 32")
    }
    
    next_power = lowlevel.utils.next_power_of_two(1000)  // Should be 1024
    if next_power != 1024 {
        crystal.manifest("ERROR: NEXT_POWER_OF_TWO(1000) = " + next_power + ", expected 1024")
    } else {
        crystal.manifest("✓ Next power of two: NEXT_POWER_OF_TWO(1000) = 1024")
    }
    
    // Test edge cases for next_power_of_two
    next_power = lowlevel.utils.next_power_of_two(0)  // Should be 1 (special case)
    if next_power != 1 {
        crystal.manifest("ERROR: NEXT_POWER_OF_TWO(0) = " + next_power + ", expected 1")
    } else {
        crystal.manifest("✓ Next power of two: NEXT_POWER_OF_TWO(0) = 1 (special case)")
    }
    
    next_power = lowlevel.utils.next_power_of_two(-5)  // Should be 1 (special case for negative)
    if next_power != 1 {
        crystal.manifest("ERROR: NEXT_POWER_OF_TWO(-5) = " + next_power + ", expected 1")
    } else {
        crystal.manifest("✓ Next power of two: NEXT_POWER_OF_TWO(-5) = 1 (negative case)")
    }
    
    crystal.manifest("Power of two utilities tests completed!")
}

func test_swap_xor_function() -> Void {
    crystal.manifest("Testing XOR swap utility function...")
    
    // Test swap_xor function (this function is unusual as it takes two values and returns a list of swapped values)
    // This is not a standard in-place swap but returns new values
    var result = lowlevel.utils.swap_xor(10, 20)
    if result[0] != 20 or result[1] != 10 {
        crystal.manifest("ERROR: SWAP_XOR(10, 20) = [" + result[0] + ", " + result[1] + "], expected [20, 10]")
    } else {
        crystal.manifest("✓ XOR swap: SWAP_XOR(10, 20) = [20, 10]")
    }
    
    // Test with same values
    result = lowlevel.utils.swap_xor(5, 5)
    if result[0] != 5 or result[1] != 5 {
        crystal.manifest("ERROR: SWAP_XOR(5, 5) = [" + result[0] + ", " + result[1] + "], expected [5, 5]")
    } else {
        crystal.manifest("✓ XOR swap with same values: SWAP_XOR(5, 5) = [5, 5]")
    }
    
    // Test with zero
    result = lowlevel.utils.swap_xor(0, 42)
    if result[0] != 42 or result[1] != 0 {
        crystal.manifest("ERROR: SWAP_XOR(0, 42) = [" + result[0] + ", " + result[1] + "], expected [42, 0]")
    } else {
        crystal.manifest("✓ XOR swap with zero: SWAP_XOR(0, 42) = [42, 0]")
    }
    
    crystal.manifest("XOR swap utility function test completed!")
}

func test_other_utilities() -> Void {
    crystal.manifest("Testing other utility functions...")
    
    // Test is_power_of_two with boundary values
    var result = lowlevel.utils.is_power_of_two(2147483648)  // 2^31 (if supported)
    crystal.manifest("IS_POWER_OF_TWO(" + 2147483648 + ") = " + result + " (large power of two)")
    
    // Test next_power_of_two with large values
    var next_power = lowlevel.utils.next_power_of_two(1000000)
    crystal.manifest("NEXT_POWER_OF_TWO(1000000) = " + next_power + " (large number)")
    
    // Test alignment with large values
    var aligned = lowlevel.utils.align_up(999999, 1024)
    var expected_aligned = 1000448  // Next multiple of 1024 after 999999
    if aligned != expected_aligned {
        crystal.manifest("ERROR: ALIGN_UP(999999, 1024) = " + aligned + ", expected " + expected_aligned)
    } else {
        crystal.manifest("✓ Large alignment: 999999 -> 1000448 (1024-byte boundary)")
    }
    
    crystal.manifest("Other utility functions tests completed!")
}

func main() -> Void {
    test_endian_conversion()
    test_alignment_functions()
    test_power_of_two_functions()
    test_swap_xor_function()
    test_other_utilities()
    
    crystal.manifest("All utility functions tests completed!")
}