// Comprehensive Bitwise Operations Test Suite
// Extensive testing of all bitwise operations for edge cases and bugs

import lowlevel
import lowlevel.bitwise
import crystal

func test_basic_bitwise_operations() -> Void {
    crystal.manifest("Testing basic bitwise operations...")
    
    // Test AND operation
    var result = lowlevel.bitwise.and(12, 10)  // 1100 & 1010 = 1000 = 8
    if result != 8 {
        crystal.manifest("ERROR: AND(12, 10) = " + result + ", expected 8")
    } else {
        crystal.manifest("✓ AND operation passed")
    }
    
    // Test OR operation
    result = lowlevel.bitwise.or(12, 10)  // 1100 | 1010 = 1110 = 14
    if result != 14 {
        crystal.manifest("ERROR: OR(12, 10) = " + result + ", expected 14")
    } else {
        crystal.manifest("✓ OR operation passed")
    }
    
    // Test XOR operation
    result = lowlevel.bitwise.xor(12, 10)  // 1100 ^ 1010 = 0110 = 6
    if result != 6 {
        crystal.manifest("ERROR: XOR(12, 10) = " + result + ", expected 6")
    } else {
        crystal.manifest("✓ XOR operation passed")
    }
    
    // Test NOT operation
    result = lowlevel.bitwise.not(5)  // ~5 = ...11111010 (two's complement)
    crystal.manifest("NOT operation: ~5 = " + result)  // This will be negative, so just log
    
    // Edge cases for basic operations
    result = lowlevel.bitwise.and(0, 255)  // Should be 0
    if result != 0 {
        crystal.manifest("ERROR: AND(0, 255) = " + result + ", expected 0")
    } else {
        crystal.manifest("✓ AND with 0 passed")
    }
    
    result = lowlevel.bitwise.or(0, 255)  // Should be 255
    if result != 255 {
        crystal.manifest("ERROR: OR(0, 255) = " + result + ", expected 255")
    } else {
        crystal.manifest("✓ OR with 0 passed")
    }
    
    result = lowlevel.bitwise.xor(255, 255)  // Should be 0
    if result != 0 {
        crystal.manifest("ERROR: XOR(255, 255) = " + result + ", expected 0")
    } else {
        crystal.manifest("✓ XOR with same value passed")
    }
    
    crystal.manifest("Basic bitwise operations test completed!")
}

func test_shift_operations() -> Void {
    crystal.manifest("Testing shift operations...")
    
    // Test left shift
    var result = lowlevel.bitwise.left_shift(5, 2)  // 101 << 2 = 10100 = 20
    if result != 20 {
        crystal.manifest("ERROR: LEFT_SHIFT(5, 2) = " + result + ", expected 20")
    } else {
        crystal.manifest("✓ Left shift passed")
    }
    
    // Test right shift
    result = lowlevel.bitwise.right_shift(20, 2)  // 10100 >> 2 = 101 = 5
    if result != 5 {
        crystal.manifest("ERROR: RIGHT_SHIFT(20, 2) = " + result + ", expected 5")
    } else {
        crystal.manifest("✓ Right shift passed")
    }
    
    // Test edge cases
    result = lowlevel.bitwise.left_shift(1, 0)  // Should remain 1
    if result != 1 {
        crystal.manifest("ERROR: LEFT_SHIFT(1, 0) = " + result + ", expected 1")
    } else {
        crystal.manifest("✓ Left shift with 0 passed")
    }
    
    result = lowlevel.bitwise.right_shift(255, 0)  // Should remain 255
    if result != 255 {
        crystal.manifest("ERROR: RIGHT_SHIFT(255, 0) = " + result + ", expected 255")
    } else {
        crystal.manifest("✓ Right shift with 0 passed")
    }
    
    // Test shift with large values
    result = lowlevel.bitwise.left_shift(1, 31)  // Should be 2^31 (large positive)
    crystal.manifest("LEFT_SHIFT(1, 31) = " + result)  // Log large value
    
    // Test shift beyond bit width (behavior depends on implementation)
    result = lowlevel.bitwise.left_shift(1, 33)  // 33 > 32, behavior depends
    crystal.manifest("LEFT_SHIFT(1, 33) = " + result)  // Log result
    
    crystal.manifest("Shift operations test completed!")
}

func test_bit_manipulation() -> Void {
    crystal.manifest("Testing bit manipulation operations...")
    
    // Test set bit
    var value = 0
    value = lowlevel.bitwise.set_bit(value, 3)  // Set bit 3: 0000 -> 1000 = 8
    if value != 8 {
        crystal.manifest("ERROR: SET_BIT(0, 3) = " + value + ", expected 8")
    } else {
        crystal.manifest("✓ Set bit passed")
    }
    
    // Test clear bit
    value = 15  // 1111
    value = lowlevel.bitwise.clear_bit(value, 2)  // Clear bit 2: 1111 -> 1011 = 11
    if value != 11 {
        crystal.manifest("ERROR: CLEAR_BIT(15, 2) = " + value + ", expected 11")
    } else {
        crystal.manifest("✓ Clear bit passed")
    }
    
    // Test toggle bit
    value = 15  // 1111
    value = lowlevel.bitwise.toggle_bit(value, 1)  // Toggle bit 1: 1111 -> 1101 = 13
    if value != 13 {
        crystal.manifest("ERROR: TOGGLE_BIT(15, 1) = " + value + ", expected 13")
    } else {
        crystal.manifest("✓ Toggle bit passed")
    }
    
    // Test test bit
    var is_set = lowlevel.bitwise.test_bit(15, 3)  // Bit 3 of 15 (1111) should be true
    if not is_set {
        crystal.manifest("ERROR: TEST_BIT(15, 3) = false, expected true")
    } else {
        crystal.manifest("✓ Test bit passed (15, 3)")
    }
    
    is_set = lowlevel.bitwise.test_bit(7, 3)  // Bit 3 of 7 (0111) should be false
    if is_set {
        crystal.manifest("ERROR: TEST_BIT(7, 3) = true, expected false")
    } else {
        crystal.manifest("✓ Test bit passed (7, 3)")
    }
    
    // Test on larger values
    value = 255  // 11111111
    value = lowlevel.bitwise.set_bit(value, 10)  // Set bit 10
    var expected = 255 + (1 << 10)  // 255 + 1024 = 1279
    if value != expected {
        crystal.manifest("ERROR: SET_BIT(255, 10) = " + value + ", expected " + expected)
    } else {
        crystal.manifest("✓ Set bit larger value passed")
    }
    
    crystal.manifest("Bit manipulation test completed!")
}

func test_bit_counting_operations() -> Void {
    crystal.manifest("Testing bit counting operations...")
    
    // Test population count
    var count = lowlevel.bitwise.pop_count(15)  // 1111 has 4 set bits
    if count != 4 {
        crystal.manifest("ERROR: POP_COUNT(15) = " + count + ", expected 4")
    } else {
        crystal.manifest("✓ Pop count passed (15)")
    }
    
    count = lowlevel.bitwise.pop_count(0)  // 0 has 0 set bits
    if count != 0 {
        crystal.manifest("ERROR: POP_COUNT(0) = " + count + ", expected 0")
    } else {
        crystal.manifest("✓ Pop count passed (0)")
    }
    
    count = lowlevel.bitwise.pop_count(255)  // 11111111 has 8 set bits
    if count != 8 {
        crystal.manifest("ERROR: POP_COUNT(255) = " + count + ", expected 8")
    } else {
        crystal.manifest("✓ Pop count passed (255)")
    }
    
    // Test counting zeros
    var zeros = lowlevel.bitwise.count_trailing_zeros(8)  // 1000 has 3 trailing zeros
    if zeros != 3 {
        crystal.manifest("ERROR: COUNT_TRAILING_ZEROS(8) = " + zeros + ", expected 3")
    } else {
        crystal.manifest("✓ Count trailing zeros passed (8)")
    }
    
    zeros = lowlevel.bitwise.count_trailing_zeros(15)  // 1111 has 0 trailing zeros
    if zeros != 0 {
        crystal.manifest("ERROR: COUNT_TRAILING_ZEROS(15) = " + zeros + ", expected 0")
    } else {
        crystal.manifest("✓ Count trailing zeros passed (15)")
    }
    
    // Count leading zeros (this may be implementation dependent)
    zeros = lowlevel.bitwise.count_leading_zeros(0)  // Should be 32 for 32-bit zero
    crystal.manifest("COUNT_LEADING_ZEROS(0) = " + zeros)  // Log result
    
    crystal.manifest("Bit counting operations test completed!")
}

func test_bit_field_operations() -> Void {
    crystal.manifest("Testing bit field operations...")
    
    // Test extract bit field
    var value = 0b11110000  // 240 in decimal
    var field = lowlevel.bitwise.extract_bit_field(value, 2, 3)  // Extract 3 bits starting at pos 2: 11110[111]0 = 111 = 7
    if field != 7 {
        crystal.manifest("ERROR: EXTRACT_BIT_FIELD(240, 2, 3) = " + field + ", expected 7")
    } else {
        crystal.manifest("✓ Extract bit field (240, 2, 3) passed")
    }
    
    // Test insert bit field
    var target = 0b10101010  // 170
    var field_to_insert = 5  // 101 in binary
    var result = lowlevel.bitwise.insert_bit_field(target, field_to_insert, 1, 3)  // Insert 101 at pos 1-3
    // Original: 10101010
    // Position 1-3 (3 bits): bits 1,2,3
    // Clear those: 10100010 (cleared bits 1-3)
    // Insert 101: 10101110 = 174
    if result != 174 {
        crystal.manifest("ERROR: INSERT_BIT_FIELD(170, 5, 1, 3) = " + result + ", expected 174")
        crystal.manifest("       Original: 10101010, inserting 101 at positions 1-3")
    } else {
        crystal.manifest("✓ Insert bit field passed")
    }
    
    // Test with different values
    target = 0
    field_to_insert = 0b1111  // 4 bits of 1s
    result = lowlevel.bitwise.insert_bit_field(target, field_to_insert, 4, 4)  // Insert 1111 at pos 4-7
    // Should result in 11110000 = 240
    if result != 240 {
        crystal.manifest("ERROR: INSERT_BIT_FIELD(0, 15, 4, 4) = " + result + ", expected 240")
    } else {
        crystal.manifest("✓ Insert bit field (0, 15, 4, 4) passed")
    }
    
    crystal.manifest("Bit field operations test completed!")
}

func test_rotation_operations() -> Void {
    crystal.manifest("Testing rotation operations...")
    
    // Note: The rotation operations may have issues with bit width assumptions
    // Let's test with a known value and document expectations
    
    var value = 0b11000001  // 193 in decimal, 8-bit pattern: 11000001
    // For 8-bit rotation left by 2: 11000001 -> 00000111 (with rotation)
    // However, our implementation assumes 32/64-bit integers, so results will differ
    
    var rotated = lowlevel.bitwise.rotate_left(value, 2)  
    crystal.manifest("ROTATE_LEFT(193, 2) = " + rotated + " (result will depend on bit width)")
    
    rotated = lowlevel.bitwise.rotate_right(value, 2)
    crystal.manifest("ROTATE_RIGHT(193, 2) = " + rotated + " (result will depend on bit width)")
    
    // Test with simpler case
    value = 0b00000011  // 3, rotate left by 1
    rotated = lowlevel.bitwise.rotate_left(value, 1)
    crystal.manifest("ROTATE_LEFT(3, 1) = " + rotated)
    
    crystal.manifest("Rotation operations test completed!")
}

func main() -> Void {
    test_basic_bitwise_operations()
    test_shift_operations()
    test_bit_manipulation()
    test_bit_counting_operations()
    test_bit_field_operations()
    test_rotation_operations()
    
    crystal.manifest("All bitwise operations tests completed!")
}