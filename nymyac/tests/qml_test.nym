// Quantum ML (QML) Circuit Test
// Demonstrating a small parameterized quantum circuit for machine learning

import quantum
import quantum.sim
import quantum.gate
import math
import ml
import ml.quantum_ml
import crystal

func test_simple_qml_circuit() -> Void {
    crystal.manifest("=== Testing Simple QML Circuit ===")
    
    // Create a simple 2-qubit parameterized quantum circuit for classification
    var circuit = quantum.sim.create_circuit(2)
    crystal.manifest("Created 2-qubit quantum circuit")
    
    // Initialize circuit parameters
    var parameters = [math.PI / 4.0, math.PI / 3.0, math.PI / 6.0]  // 3 parameters for rotations
    
    crystal.manifest("Circuit parameters: " + parameters.join(", "))
    
    // Apply parameterized rotations
    // Layer 1: Encode input data as rotations
    var input_data = [0.5, 0.8]  // Sample input data
    
    // Encode first data point
    quantum.gate.ry(circuit, 0, input_data[0])  // Apply Ry rotation to qubit 0
    crystal.manifest("Applied Ry rotation with angle: " + input_data[0] + " to qubit 0")
    
    // Encode second data point  
    quantum.gate.ry(circuit, 1, input_data[1])  // Apply Ry rotation to qubit 1
    crystal.manifest("Applied Ry rotation with angle: " + input_data[1] + " to qubit 1")
    
    // Apply parameterized rotations using our parameters
    // Apply first parameter to first qubit
    quantum.gate.rz(circuit, 0, parameters[0])
    crystal.manifest("Applied Rz rotation with parameter: " + parameters[0] + " to qubit 0")
    
    // Apply second parameter to second qubit
    quantum.gate.rz(circuit, 1, parameters[1])
    crystal.manifest("Applied Rz rotation with parameter: " + parameters[1] + " to qubit 1")
    
    // Entangle the qubits using CNOT gate
    quantum.gate.cx(circuit, 0, 1)  // Control qubit 0, target qubit 1
    crystal.manifest("Applied CNOT gate: entangling qubits 0 and 1")
    
    // Apply third parameter to first qubit again
    quantum.gate.ry(circuit, 0, parameters[2])
    crystal.manifest("Applied Ry rotation with parameter: " + parameters[2] + " to qubit 0")
    
    // Measure the circuit to get output
    var results = quantum.sim.measure_all(circuit)
    crystal.manifest("Measurement results: qubit 0 = " + results[0] + ", qubit 1 = " + results[1])
    
    // Calculate probabilities by running the circuit multiple times
    var counts = [0, 0, 0, 0]  // Count for |00>, |01>, |10>, |11> states
    var num_runs = 1000
    
    for run in range(num_runs) {
        var temp_circuit = quantum.sim.create_circuit(2)

        // Rebuild the circuit with same operations for this run
        quantum.gate.ry(temp_circuit, 0, input_data[0])
        quantum.gate.ry(temp_circuit, 1, input_data[1])
        quantum.gate.rz(temp_circuit, 0, parameters[0])
        quantum.gate.rz(temp_circuit, 1, parameters[1])
        quantum.gate.cx(temp_circuit, 0, 1)
        quantum.gate.ry(temp_circuit, 0, parameters[2])

        var run_results = quantum.sim.measure_all(temp_circuit)
        var state_index = run_results[0] * 2 + run_results[1]  // Convert 2-bit result to index
        counts[state_index] = counts[state_index] + 1
    }

    // Calculate probabilities
    var probs = []
    for i in range(4) {
        var prob = counts[i].toFloat() / num_runs.toFloat()
        probs.append(prob)
        crystal.manifest("State |" + i.to_binary_string(2) + "> probability: " + prob +
                        " (" + counts[i] + "/" + num_runs + " runs)")
    }
    
    crystal.manifest("QML circuit test completed!")
}

func Int.to_binary_string(width: Int) -> String {
    var result = ""
    var n = this
    for i in range(width) {
        result = (n % 2).to_string() + result
        n = n >> 1
    }
    return result
}

func test_quantum_feature_map() -> Void {
    crystal.manifest("=== Testing Quantum Feature Map ===")
    
    // Create a quantum feature map using the quantum_ml utility
    var circuit = quantum.sim.create_circuit(3)  // 3-qubit circuit
    crystal.manifest("Created 3-qubit circuit for quantum feature map")
    
    // Sample classical data to encode
    var data = [0.3, 0.7, 0.1]  // 3-dimensional input data
    crystal.manifest("Input data: [" + data.join(", ") + "]")
    
    // Encode data using Ry rotations
    for i in range(data.length) {
        quantum.gate.ry(circuit, i, data[i] * 2.0 * math.PI)  // Scale to 0-2π range
    }
    
    crystal.manifest("Applied Ry rotations to encode classical data into quantum state")
    
    // Add entangling layers to create superposition of data features
    // Layer 1 entanglements
    quantum.gate.cx(circuit, 0, 1)  // Entangle qubits 0 and 1
    quantum.gate.cx(circuit, 1, 2)  // Entangle qubits 1 and 2
    
    crystal.manifest("Applied entangling gates to create quantum superposition of features")
    
    // Measure circuit to observe the quantum state properties
    var results = []
    var num_measurements = 1000
    
    for i in range(num_measurements) {
        var temp_circuit = quantum.sim.create_circuit(3)
        
        // Rebuild the circuit with same operations
        for j in range(data.length) {
            quantum.gate.ry(temp_circuit, j, data[j] * 2.0 * math.PI)
        }
        quantum.gate.cx(temp_circuit, 0, 1)
        quantum.gate.cx(temp_circuit, 1, 2)
        
        var meas_result = quantum.sim.measure_all(temp_circuit)
        results.append(meas_result)
    }
    
    // Count the frequency of different outcomes (this is a simplification)
    var outcome_counts = [0, 0, 0, 0, 0, 0, 0, 0]  // For 3-qubit states
    for result in results {
        var idx = result[0] * 4 + result[1] * 2 + result[2]  // Convert to 3-bit index
        if idx < 8 {
            outcome_counts[idx] = outcome_counts[idx] + 1
        }
    }
    
    for i in range(8) {
        var prob = outcome_counts[i].toFloat() / num_measurements.toFloat()
        crystal.manifest("State |" + i.to_binary_string(3) + ">: " + prob + " (" + outcome_counts[i] + "/" + num_measurements + ")")
    }
    
    crystal.manifest("Quantum feature map test completed!")
}

func test_variational_classifier() -> Void {
    crystal.manifest("=== Testing Variational Classifier ===")
    
    // Create a variational classifier using the quantum ML library
    var classifier = ml.quantum_ml.VariationalClassifier(3, 2)  // 3 qubits, 2 classes
    crystal.manifest("Created variational classifier with 3 qubits and 2 classes")
    
    // Sample input data
    var sample_input = [0.8, 0.4, 0.6]
    crystal.manifest("Input data for classification: [" + sample_input.join(", ") + "]")
    
    // Get prediction
    var prediction_probabilities = classifier.forward(sample_input)
    var predicted_class = classifier.predict(sample_input)
    
    crystal.manifest("Prediction probabilities: [" + prediction_probabilities.join(", ") + "]")
    crystal.manifest("Predicted class: " + predicted_class)
    
    crystal.manifest("Variational classifier test completed!")
}

func test_simple_quantum_circuit() -> Void {
    crystal.manifest("=== Testing Simple Quantum Circuit for ML ===")
    
    // Create a simple quantum circuit that performs a basic ML-relevant operation
    var circuit = quantum.sim.create_circuit(2)
    
    // Prepare initial state: |00⟩
    crystal.manifest("Starting with |00⟩ state")
    
    // Apply Hadamard to first qubit to create superposition
    quantum.gate.h(circuit, 0)
    crystal.manifest("Applied Hadamard gate to qubit 0 (creating superposition)")
    
    // Apply rotation to second qubit based on input data
    var input_weight = 0.5 * math.PI  // π/2
    quantum.gate.ry(circuit, 1, input_weight)
    crystal.manifest("Applied Ry rotation (π/2) to qubit 1")
    
    // Entangle the qubits
    quantum.gate.cx(circuit, 0, 1)
    crystal.manifest("Applied CNOT gate to entangle qubits")
    
    // Measure to get output
    var statevector = circuit.get_statevector()
    crystal.manifest("Final statevector has " + statevector.length + " components")
    
    for i in range(statevector.length) {
        var amplitude = statevector[i]
        var probability = amplitude.magnitude() * amplitude.magnitude()
        crystal.manifest("Amplitude for |" + i.to_binary_string(2) + ">: " + 
                         amplitude.real + " + " + amplitude.imag + "i (prob: " + probability + ")")
    }
    
    // Perform measurements to get classical outcomes
    var measurements = []
    for trial in range(100) {
        var temp_circuit = quantum.sim.create_circuit(2)
        quantum.gate.h(temp_circuit, 0)
        quantum.gate.ry(temp_circuit, 1, input_weight)
        quantum.gate.cx(temp_circuit, 0, 1)
        var result = quantum.sim.measure_all(temp_circuit)
        measurements.append(result[0] * 2 + result[1])
    }
    
    // Count outcomes
    var outcome_counts = [0, 0, 0, 0]  // |00⟩, |01⟩, |10⟩, |11⟩
    for measurement in measurements {
        outcome_counts[measurement] = outcome_counts[measurement] + 1
    }
    
    crystal.manifest("Measurement statistics from 100 runs:")
    var outcomes = ["|00⟩", "|01⟩", "|10⟩", "|11⟩"]
    for i in range(4) {
        crystal.manifest("  " + outcomes[i] + ": " + outcome_counts[i] + " times (" + 
                         (outcome_counts[i].toFloat() * 100.0 / 100.0).to_string() + "%)")
    }
    
    crystal.manifest("Simple quantum circuit test completed!")
}

func main() -> Void {
    test_simple_quantum_circuit()
    crystal.manifest("")
    
    test_simple_qml_circuit()
    crystal.manifest("")
    
    test_quantum_feature_map()
    crystal.manifest("")
    
    test_variational_classifier()
    crystal.manifest("")
    
    crystal.manifest("=== ALL QML CIRCUIT TESTS COMPLETED SUCCESSFULLY! ===")
}