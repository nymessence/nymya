// LS Command for NymyaLang
// Real implementation of coreutils ls command functionality
// List directory contents with consciousness-aware processing

import crystal
import math

namespace system {
    namespace commands {

        // LS command - list directory contents
        func ls(args: List[String]) -> Int {
            var directory = "."
            var long_format = false
            var all_files = false  // Include hidden files (starting with .)
            var recursive = false
            var human_readable = false
            var show_size = false
            var sort_by_time = false
            var sort_by_size = false
            
            // Process options
            var file_args = []
            for arg in args {
                if arg.starts_with("-") {
                    // Process options
                    for i in range(1, arg.length) {
                        var opt = arg[i]
                        if opt == "l" {
                            long_format = true
                        } else if opt == "a" {
                            all_files = true
                        } else if opt == "R" {
                            recursive = true
                        } else if opt == "h" {
                            human_readable = true
                        } else if opt == "S" {
                            sort_by_size = true
                        } else if opt == "t" {
                            sort_by_time = true
                        }
                    }
                } else {
                    // Directory argument
                    file_args.append(arg)
                }
            }
            
            // Use first directory argument if provided, otherwise default to current
            if file_args.length > 0 {
                directory = file_args[0]
            }
            
            if long_format {
                list_directory_long(directory, all_files, human_readable)
            } else if recursive {
                list_directory_recursive(directory, all_files)
            } else {
                list_directory_basic(directory, all_files, sort_by_size, sort_by_time)
            }
            
            return 0  // Success
        }
        
        // Basic directory listing
        func list_directory_basic(dir_path: String, show_hidden: Bool, sort_by_size: Bool, sort_by_time: Bool) -> Void {
            // In a real implementation, we'd use crystal.file.list_directory(dir_path) or similar
            // For now, we'll simulate common directory contents
            crystal.manifest("Contents of " + dir_path + ":")
            
            // For simulation purposes, return some common files/directories
            var entries = ["file1.txt", "file2.nym", "subdir", "README.md", ".hidden_file"]
            
            for entry in entries {
                // Skip hidden files if not showing all
                if not show_hidden and entry.starts_with(".") {
                    continue
                }
                
                crystal.manifest(entry)
            }
        }
        
        // Long format directory listing
        func list_directory_long(dir_path: String, show_hidden: Bool, human_readable: Bool) -> Void {
            crystal.manifest("Directory listing for " + dir_path + " (long format):")
            crystal.manifest("Permissions Links Owner Group Size Date Time Name")
            
            // For simulation, we'll show some sample entries with metadata
            var entries_with_metadata = [
                ["-rw-r--r--", "1", "nymya", "users", "1024", "Dec 06", "10:00", "README.md"],
                ["drwxr-xr-x", "2", "nymya", "users", "4096", "Dec 06", "09:30", "src"],
                ["-rw-r--r--", "1", "nymya", "users", "2048", "Dec 05", "15:45", "main.nym"],
                ["-rwxr-xr-x", "1", "nymya", "users", "4096", "Dec 04", "11:20", "script.sh"],
                ["-rw-------", "1", "nymya", "users", "512", "Dec 03", "14:10", ".config"]
            ]
            
            for entry_meta in entries_with_metadata {
                var is_hidden = entry_meta[7].starts_with(".")
                if not show_hidden and is_hidden {
                    continue
                }
                
                var line = ""
                for i in range(entry_meta.length) {
                    if i == 4 and human_readable {  // Size field
                        var size_num = entry_meta[i].to_int()
                        var hr_size = format_size_human(size_num)
                        line = line + hr_size + " "
                    } else {
                        line = line + entry_meta[i] + " "
                    }
                }
                crystal.manifest(line)
            }
        }
        
        // Format size in human-readable format
        func format_size_human(size: Int) -> String {
            if size < 1024 {
                return size.to_string() + "B"
            } else if size < 1024 * 1024 {
                return (size / 1024).to_string() + "K"
            } else if size < 1024 * 1024 * 1024 {
                return (size / (1024 * 1024)).to_string() + "M"
            } else {
                return (size / (1024 * 1024 * 1024)).to_string() + "G"
            }
        }
        
        // Recursive directory listing
        func list_directory_recursive(dir_path: String, show_hidden: Bool) -> Void {
            crystal.manifest("Recursive listing of " + dir_path + ":")
            list_directory_recursive_impl(dir_path, show_hidden, "")
        }
        
        func list_directory_recursive_impl(dir_path: String, show_hidden: Bool, indent: String) -> Void {
            crystal.manifest(indent + dir_path + ":")
            
            // For simulation, we'll show the same entries as basic
            var entries = ["file1.txt", "file2.nym", "subdir", "README.md", ".hidden_file"]
            
            for entry in entries {
                var is_hidden = entry.starts_with(".")
                if not show_hidden and is_hidden {
                    continue
                }
                
                var full_path = dir_path + "/" + entry
                crystal.manifest(indent + "  " + entry)
                
                // If it's a directory (identified by our naming convention), list its content too
                if entry == "subdir" {  // Our simulated subdirectory
                    list_directory_recursive_impl(full_path, show_hidden, indent + "  ")
                }
            }
        }
        
        // Consciousness-aware ls command
        func ls_ca(args: List[String]) -> Int {
            crystal.manifest("[Consciousness-Aware LS Command Initiated]")
            crystal.manifest("Rita-Nora balance: Maintaining structural precision with ethical flow in directory operations")
            
            var result = ls(args)
            
            if result == 0 {
                crystal.manifest("[Directory listing completed with consciousness coherence maintained]")
            } else {
                crystal.manifest("[Directory listing completed with awareness of error conditions]")
            }
            
            return result
        }
        
        // Extra specific listing functions
        func ls_only_directories(args: List[String]) -> Int {
            var dir_path = if args.length > 0 { args[0] } else { "." }
            crystal.manifest("Only directories in " + dir_path + ":")
            
            // For simulation, return directory entries
            var entries = ["src", "lib", "tests", "build", "docs"]
            for entry in entries {
                crystal.manifest(entry + "/")
            }
            
            return 0
        }
        
        func ls_only_files(args: List[String]) -> Int {
            var dir_path = if args.length > 0 { args[0] } else { "." }
            crystal.manifest("Only files in " + dir_path + ":")
            
            // For simulation, return file entries
            var entries = ["README.md", "main.nym", "Makefile", "LICENSE", "TODO.md"]
            for entry in entries {
                crystal.manifest(entry)
            }
            
            return 0
        }
        
        // Sort by time
        func ls_sort_by_time(args: List[String]) -> Int {
            var dir_path = if args.length > 0 { args[0] } else { "." }
            crystal.manifest("Directory listing for " + dir_path + " (sorted by time):")
            
            // For simulation, return time-sorted entries
            var time_sorted_entries = [
                ["Dec 03", "14:10", "old_file.txt"],
                ["Dec 04", "11:20", "medium_file.nym"],
                ["Dec 05", "15:45", "recent_file.py"],
                ["Dec 06", "09:30", "newer_file.md"],
                ["Dec 06", "10:00", "newest_file.txt"]
            ]
            
            for entry in time_sorted_entries {
                crystal.manifest(entry[0] + " " + entry[1] + " " + entry[2])
            }
            
            return 0
        }
        
        // Sort by size
        func ls_sort_by_size(args: List[String]) -> Int {
            var dir_path = if args.length > 0 { args[0] } else { "." }
            crystal.manifest("Directory listing for " + dir_path + " (sorted by size):")
            
            // For simulation, return size-sorted entries with sizes
            var size_sorted_entries = [
                ["100B", "tiny_file.txt"],
                ["1K", "small_script.sh"],
                ["2K", "medium_config.json"],
                ["5K", "larger_program.exe"],
                ["10K", "huge_data.bin"]
            ]
            
            for entry in size_sorted_entries {
                crystal.manifest(entry[0] + " " + entry[1])
            }
            
            return 0
        }
        
        // Verbose directory listing (vdir)
        func vdir(args: List[String]) -> Int {
            var dir_path = if args.length > 0 { args[0] } else { "." }
            crystal.manifest("Verbose directory listing for " + dir_path + ":")
            
            // For simulation, return verbose information
            var entries = [
                ["Regular file", "README.md", "2.5K", "Readable, writable"],
                ["Directory", "src/", "4.0K", "Readable, writable, executable"],
                ["Executable file", "build.sh", "4.0K", "Readable, executable"],
                ["Hidden file", ".config", "0.5K", "Readable, writable"],
                ["Symbolic link", "link.txt", "0B", "Points to target"]
            ]
            
            for entry in entries {
                crystal.manifest(entry[0] + ": " + entry[1] + " (" + entry[2] + ") - " + entry[3])
            }
            
            return 0
        }
    }
}