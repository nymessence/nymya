// DateTime Library for NymyaLang
// Provides datetime functionality with timezone support using 64-bit Unix time

import crystal

namespace datetime {

    // 64-bit Unix timestamp (seconds since Jan 1, 1970 UTC)
    class Timestamp {
        value: Int  // Unix timestamp in seconds

        init(seconds: Int) {
            this.value = seconds
        }

        init() {
            // Initialize to current time using system call
            this.value = get_current_time()
        }

        func get_current_time() -> Int {
            // Use system call to get current Unix timestamp
            return crystal.cpp.time.time(crystal.cpp.cstdlib.NULL).to_int()
        }

        func to_string() -> String {
            return this.value.to_string() + "s since Unix epoch"
        }

        func add_seconds(seconds: Int) -> Timestamp {
            return Timestamp(this.value + seconds)
        }

        func add_minutes(minutes: Int) -> Timestamp {
            return this.add_seconds(minutes * 60)
        }

        func add_hours(hours: Int) -> Timestamp {
            return this.add_seconds(hours * 3600)
        }

        func add_days(days: Int) -> Timestamp {
            return this.add_seconds(days * 86400)
        }

        func diff(other: Timestamp) -> Int {
            return this.value - other.value
        }
    }

    // Timezone representation
    class Timezone {
        name: String
        offset_seconds: Int  // Offset from UTC in seconds
        dst_offset: Int      // Daylight saving time offset in seconds
        has_dst: Bool        // Whether this timezone observes DST

        init(name: String, offset: Int) {
            this.name = name
            this.offset_seconds = offset
            this.dst_offset = 0
            this.has_dst = false
        }

        init(name: String, offset: Int, dst_offset: Int, has_dst: Bool) {
            this.name = name
            this.offset_seconds = offset
            this.dst_offset = dst_offset
            this.has_dst = has_dst
        }

        // Standard timezones
        static func utc() -> Timezone {
            return Timezone("UTC", 0)
        }

        static func gmt() -> Timezone {
            return Timezone("GMT", 0)
        }

        static func est() -> Timezone {
            return Timezone("EST", -18000)  // UTC-5
        }

        static func edt() -> Timezone {
            return Timezone("EDT", -14400, -3600, true)  // UTC-4 with DST
        }

        static func pst() -> Timezone {
            return Timezone("PST", -28800)  // UTC-8
        }

        static func pdt() -> Timezone {
            return Timezone("PDT", -25200, -3600, true)  // UTC-7 with DST
        }

        static func jst() -> Timezone {
            return Timezone("JST", 32400)  // UTC+9
        }

        static func cet() -> Timezone {
            return Timezone("CET", 3600)   // UTC+1
        }

        static func cest() -> Timezone {
            return Timezone("CEST", 7200, -3600, true)  // UTC+2 with DST
        }
    }

    // DateTime class with timezone support
    class DateTime {
        unix_timestamp: Timestamp
        timezone: Timezone

        init(timestamp: Timestamp, tz: Timezone) {
            this.unix_timestamp = timestamp
            this.timezone = tz
        }

        init(timestamp: Int, tz: Timezone) {
            this.init(Timestamp(timestamp), tz)
        }

        init(tz: Timezone) {
            this.init(Timestamp(), tz)
        }

        init() {
            this.init(Timezone.utc())
        }

        // Parse ISO 8601 format datetime string
        static func parse_iso(iso_string: String) -> DateTime {
            // Simplified parsing for example - real implementation would be more complex
            // Format: YYYY-MM-DDTHH:MM:SSZ or YYYY-MM-DDTHH:MM:SS+HH:MM
            
            // For now, return current time in UTC as a placeholder
            return DateTime(Timezone.utc())
        }

        // Convert timestamp to local time components
        func get_local_time() -> TimeComponents {
            var adjusted_timestamp = this.unix_timestamp.value + this.timezone.offset_seconds
            
            // Apply DST offset if applicable (simplified logic)
            if this.timezone.has_dst and is_dst_time(adjusted_timestamp) {
                adjusted_timestamp = adjusted_timestamp + this.timezone.dst_offset
            }
            
            return timestamp_to_components(adjusted_timestamp)
        }

        // Internal function to convert Unix timestamp to time components
        func timestamp_to_components(timestamp: Int) -> TimeComponents {
            var secs = timestamp
            var days = secs / 86400
            var seconds_in_day = secs % 86400
            
            var hours = seconds_in_day / 3600
            var minutes = (seconds_in_day % 3600) / 60
            var seconds = (seconds_in_day % 60)
            
            // Simplified calculation - real implementation would need to account for leap years, etc.
            // For this implementation, we'll assume a simplified model
            var year = 1970 + (days / 365).to_int()
            var day_of_year = (days % 365).to_int()
            
            // For simplicity, we'll set some reasonable defaults
            return TimeComponents(year, day_of_year, hours.to_int(), minutes.to_int(), seconds.to_int())
        }

        // Determine if the timestamp is during DST (simplified)
        func is_dst_time(timestamp: Int) -> Bool {
            // Simplified DST logic: DST roughly from March to November in Northern Hemisphere
            var components = timestamp_to_components(timestamp)
            var month = day_of_year_to_month(components.day_of_year)
            
            // DST is roughly from March to November in Northern Hemisphere
            return month > 2 and month < 11
        }

        // Convert day of year to month (simplified)
        func day_of_year_to_month(day_of_year: Int) -> Int {
            // Simplified conversion - assumes 30 days per month
            return (day_of_year / 30) + 1
        }

        // Convert to timestamp in another timezone
        func to_timezone(target_tz: Timezone) -> DateTime {
            // First, convert to UTC
            var utc_timestamp = this.unix_timestamp.value - this.timezone.offset_seconds
            
            // Apply DST adjustment if source timezone has DST and is active
            if this.timezone.has_dst and is_dst_time(this.unix_timestamp.value) {
                utc_timestamp = utc_timestamp - this.timezone.dst_offset
            }
            
            // Apply target timezone offset
            var target_timestamp = utc_timestamp + target_tz.offset_seconds
            
            // Apply DST adjustment if target timezone has DST and is active
            if target_tz.has_dst and is_dst_time(target_timestamp) {
                target_timestamp = target_timestamp + target_tz.dst_offset
            }
            
            return DateTime(Timestamp(target_timestamp), target_tz)
        }

        // Format as ISO 8601 string
        func to_iso_string() -> String {
            var local = this.get_local_time()
            return format_time_components_iso(local)
        }

        // Format time components as ISO string
        func format_time_components_iso(components: TimeComponents) -> String {
            var result = ""
            result = result + format_with_padding(components.year, 4) + "-"
            result = result + format_with_padding(components.day_of_year, 3) + "T"  // This should be month-day, simplified
            result = result + format_with_padding(components.hour, 2) + ":"
            result = result + format_with_padding(components.minute, 2) + ":"
            result = result + format_with_padding(components.second, 2) + "+"
            result = result + format_offset(this.timezone.offset_seconds)
            
            return result
        }

        // Format integer with zero padding
        func format_with_padding(value: Int, width: Int) -> String {
            var str = value.to_string()
            while str.length < width {
                str = "0" + str
            }
            return str
        }

        // Format timezone offset
        func format_offset(offset_seconds: Int) -> String {
            var hours = math.abs(offset_seconds) / 3600
            var minutes = (math.abs(offset_seconds) % 3600) / 60
            var sign = if offset_seconds >= 0 { "+" } else { "-" }
            
            return sign + format_with_padding(hours.to_int(), 2) + ":" + 
                   format_with_padding(minutes.to_int(), 2)
        }

        func to_string() -> String {
            var local = this.get_local_time()
            return "DateTime: " + local.year + "-" + local.day_of_year + " " + 
                   local.hour + ":" + local.minute + ":" + local.second + 
                   " in timezone " + this.timezone.name
        }
    }

    // Time components structure
    class TimeComponents {
        year: Int
        day_of_year: Int
        hour: Int
        minute: Int
        second: Int

        init(y: Int, doy: Int, h: Int, m: Int, s: Int) {
            this.year = y
            this.day_of_year = doy
            this.hour = h
            this.minute = m
            this.second = s
        }
    }

    // Utility functions
    func is_leap_year(year: Int) -> Bool {
        return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)
    }

    func get_days_in_month(month: Int, year: Int) -> Int {
        var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        
        if month == 2 and is_leap_year(year) {
            return 29
        }
        
        return days[month - 1]
    }

    // Current time functions
    func now_utc() -> DateTime {
        return DateTime(Timezone.utc())
    }

    func now_local() -> DateTime {
        // For now, we'll use a system timezone, or default to UTC
        return DateTime(Timezone.utc())
    }
}