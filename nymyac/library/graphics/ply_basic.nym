// PLY (Polygon File Format) Library for NymyaLang
// Provides functions to create and write PLY files for 3D models
// ply_basic.nym

import crystal
import system.file

namespace graphics

@dala
@shira
@ora
// Define a basic 3D point structure
class Point3D {
    var x
    var y
    var z

    func init(x_val: Float, y_val: Float, z_val: Float) -> Void {
        self.x = x_val
        self.y = y_val
        self.z = z_val
    }
}

@vertex
@color
@dala
// Define a vertex for PLY files
class Vertex {
    var x
    var y
    var z
    var r
    var g
    var b

    func init(x_val: Float, y_val: Float, z_val: Float, r_val: Int = 255, g_val: Int = 255, b_val: Int = 255) -> Void {
        self.x = x_val
        self.y = y_val
        self.z = z_val
        self.r = r_val
        self.g = g_val
        self.b = b_val
    }
}

// Define a face for PLY files (triangle)
class Face {
    var vertex_indices  // List of vertex indices that form this face

    func init(indices: List[Int]) -> Void {
        self.vertex_indices = indices
    }
}

@geometric_model
@3d_structure
@polymer
@consciousness_aware
// PLY Model structure
class PlyModel {
    var vertices
    var faces

    func init() -> Void {
        self.vertices = []
        self.faces = []
    }

    // Add a vertex to the model (outside class context - not valid here)
    func add_vertex(self, vertex: Vertex) -> Void {
        self.vertices.append(vertex)
    }

    // Add a face to the model (outside class context - not valid here)
    func add_face(self, face: Face) -> Void {
        self.faces.append(face)
    }

    // Create a tetrahedron centered at a point
    func add_tetrahedron(self, center_x: Float, center_y: Float, center_z: Float, scale: Float, r: Int = 255, g: Int = 255, b: Int = 255) -> Void {
        // Tetrahedron vertices
        var v0 = Vertex(center_x, center_y + scale, center_z, r, g, b)          // Top
        var v1 = Vertex(center_x - scale, center_y - scale, center_z - scale, r, g, b)  // Bottom left
        var v2 = Vertex(center_x + scale, center_y - scale, center_z - scale, r, g, b)  // Bottom right
        var v3 = Vertex(center_x, center_y - scale, center_z + scale, r, g, b)          // Bottom front

        var start_idx = self.vertices.length()

        self.add_vertex(v0)
        self.add_vertex(v1)
        self.add_vertex(v2)
        self.add_vertex(v3)

        // Tetrahedron faces (triangles) - make sure winding is consistent for proper normals
        self.add_face(Face([start_idx, start_idx+2, start_idx+1]))  // Front face
        self.add_face(Face([start_idx, start_idx+1, start_idx+3]))  // Left face
        self.add_face(Face([start_idx, start_idx+3, start_idx+2]))  // Right face
        self.add_face(Face([start_idx+1, start_idx+2, start_idx+3]))  // Bottom face
    }

    // Create a star tetrahedron (two interlocking tetrahedrons)
    func add_star_tetrahedron(self, center_x: Float, center_y: Float, center_z: Float, scale: Float, r: Int = 255, g: Int = 255, b: Int = 255) -> Void {
        // First tetrahedron
        self.add_tetrahedron(center_x, center_y, center_z, scale, r, g, b)

        // Second inverted tetrahedron (rotated 180 degrees)
        var v0 = Vertex(center_x, center_y - scale, center_z, r, g, b)                // Bottom
        var v1 = Vertex(center_x - scale, center_y + scale, center_z + scale, r, g, b) // Top left
        var v2 = Vertex(center_x + scale, center_y + scale, center_z + scale, r, g, b) // Top right
        var v3 = Vertex(center_x, center_y + scale, center_z - scale, r, g, b)         // Top back

        var start_idx = self.vertices.length()

        self.add_vertex(v0)
        self.add_vertex(v1)
        self.add_vertex(v2)
        self.add_vertex(v3)

        // Faces for the inverted tetrahedron
        self.add_face(Face([start_idx, start_idx+1, start_idx+2]))  // Bottom face
        self.add_face(Face([start_idx, start_idx+2, start_idx+3]))  // Right face
        self.add_face(Face([start_idx, start_idx+3, start_idx+1]))  // Left face
        self.add_face(Face([start_idx+1, start_idx+3, start_idx+2]))  // Top face
    }

    // Write the PLY model to a file
    func write_ply(self, filename: String) -> Bool {
        // Get vertex and face counts
        var vertex_count = self.vertices.length()
        var face_count = self.faces.length()

        crystal.manifest("Starting PLY file creation...")

        // Create PLY file content header
        var header = "ply\n"
        header += "format ascii 1.0\n"
        header += "comment Created with NymyaLang PLY library\n"
        // Convert count to string without using str() - using a helper function
        header += "element vertex " + int_to_string(vertex_count) + "\n"
        header += "property float x\n"
        header += "property float y\n"
        header += "property float z\n"
        header += "property uchar red\n"
        header += "property uchar green\n"
        header += "property uchar blue\n"
        header += "element face " + int_to_string(face_count) + "\n"
        header += "property list uchar int vertex_indices\n"
        header += "end_header\n"

        var content = header
        crystal.manifest("Header created, adding vertices...")

        // Add vertices
        for i in range(0, self.vertices.length()) {
            var vertex = self.vertices[i]
            content += float_to_string(vertex.x) + " " + float_to_string(vertex.y) + " " + float_to_string(vertex.z) + " "
            content += int_to_string(vertex.r) + " " + int_to_string(vertex.g) + " " + int_to_string(vertex.b) + "\n"
        }
        crystal.manifest("Vertices added, adding faces...")

        // Add faces
        for i in range(0, self.faces.length()) {
            var face = self.faces[i]
            var idx_count = face.vertex_indices.length()
            var face_str = int_to_string(idx_count)
            for j in range(0, face.vertex_indices.length()) {
                var idx = face.vertex_indices[j]
                face_str += " " + int_to_string(idx)
            }
            content += face_str + "\n"
        }
        crystal.manifest("Faces added, attempting to write file...")

        // Write to file using crystal.file.dalan_orin (used in working system code)
        var result = crystal.file.dalan_orin(filename, content)

        // Log the result for debugging
        if result {
            crystal.manifest("PLY file successfully written to: " + filename)
        } else {
            crystal.manifest("Failed to write PLY file to: " + filename)
        }

        return result
    }

    // Helper function to convert integer to string
    func int_to_string(num: Int) -> String {
        if num == 0 {
            return "0"
        }

        var is_negative = False
        if num < 0 {
            is_negative = True
            num = -num
        }

        var result = ""
        while num > 0 {
            var digit = num % 10
            result = digit_to_char(digit) + result
            num = num / 10
        }

        if is_negative {
            result = "-" + result
        }

        return result
    }

    // Helper function to convert float to string (simplified)
    func float_to_string(num: Float) -> String {
        // For now, just convert the integer part (this is a simplified approach)
        var int_part = num as Int
        var result = int_to_string(int_part)

        // Add decimal part if needed (simplified - only 2 decimal places)
        var frac_part = (num - int_part as Float) * 100.0
        if frac_part < 0 {
            frac_part = -frac_part
        }
        var frac_int = frac_part as Int

        // Only add decimal part if it's not zero
        if frac_int != 0 {
            result = result + "." + int_to_string(frac_int)
        }

        return result
    }

    // Helper function to convert single digit to character
    func digit_to_char(digit: Int) -> String {
        if digit == 0 { return "0" }
        else if digit == 1 { return "1" }
        else if digit == 2 { return "2" }
        else if digit == 3 { return "3" }
        else if digit == 4 { return "4" }
        else if digit == 5 { return "5" }
        else if digit == 6 { return "6" }
        else if digit == 7 { return "7" }
        else if digit == 8 { return "8" }
        else if digit == 9 { return "9" }
        else { return "0" } // default
    }
}

@model_factory
@creation
@nymya
@quantum_coherent
// Create a new PLY model
func create_model() -> PlyModel {
    return PlyModel()
}

// Helper function to create a star tetrahedron and save to PLY
func create_star_tetrahedron_ply(center_x: Float, center_y: Float, center_z: Float, scale: Float, filename: String) -> Bool {
    var model = PlyModel()
    model.add_star_tetrahedron(center_x, center_y, center_z, scale)
    
    return model.write_ply(filename)
}

@astronomical
@coordinate_transformation
@quantum_astronomy
@celestial_navigation
// Convert RA (Right Ascension) from HMS format to degrees
func ra_hms_to_degrees(ra_hms: String) -> Float {
    // Parse format "HHhMMmSSs" like "03h47m29s"
    var hours_str = ""
    var minutes_str = ""
    var seconds_str = ""

    // Extract hours part before 'h'
    var i = 0
    while i < length(ra_hms) and ra_hms[i] != 'h' {
        hours_str = hours_str + ra_hms[i]
        i = i + 1
    }

    if i >= length(ra_hms) {  // No 'h' found
        return 0.0
    }

    i = i + 1  // Skip 'h'

    // Extract minutes part before 'm'
    while i < length(ra_hms) and ra_hms[i] != 'm' {
        minutes_str = minutes_str + ra_hms[i]
        i = i + 1
    }

    if i >= length(ra_hms) {  // No 'm' found
        return 0.0
    }

    i = i + 1  // Skip 'm'

    // Extract seconds part before 's'
    while i < length(ra_hms) and ra_hms[i] != 's' {
        seconds_str = seconds_str + ra_hms[i]
        i = i + 1
    }

    // The last character should be 's', so seconds_str contains only the digits

    var hours = str_to_float(hours_str)
    var minutes = str_to_float(minutes_str)
    var seconds = str_to_float(seconds_str)

    // Convert to degrees: RA is typically in hours (0-24), convert to degrees (0-360)
    return (hours + minutes/60.0 + seconds/3600.0) * 15.0
}

@astronomical
@coordinate_transformation
@quantum_astronomy
@celestial_navigation
// Convert DEC (Declination) from DMS format to degrees
func dec_dms_to_degrees(dec_dms: String) -> Float {
    // Parse format "±DD°MM′SS″" like "+24°06′19″" or "-24°06′19″
    var sign = 1.0
    var start_idx = 0

    // Check for sign and adjust starting index
    if dec_dms[0] == '-' {
        sign = -1.0
        start_idx = 1
    } else if dec_dms[0] == '+' {
        start_idx = 1
    }

    // Extract degrees part before '°'
    var deg_str = ""
    var i = start_idx
    while i < length(dec_dms) and dec_dms[i] != '°' {
        deg_str = deg_str + dec_dms[i]
        i = i + 1
    }

    if i >= length(dec_dms) {  // No '°' found
        return 0.0
    }

    i = i + 1  // Skip '°'

    // Extract minutes part before '′'
    var min_str = ""
    while i < length(dec_dms) and dec_dms[i] != '′' {
        min_str = min_str + dec_dms[i]
        i = i + 1
    }

    if i >= length(dec_dms) {  // No '′' found
        return 0.0
    }

    i = i + 1  // Skip '′'

    // Extract seconds part before '″'
    var sec_str = ""
    while i < length(dec_dms) and dec_dms[i] != '″' {
        sec_str = sec_str + dec_dms[i]
        i = i + 1
    }

    var degrees = str_to_float(deg_str)
    var minutes = str_to_float(min_str)
    var seconds = str_to_float(sec_str)

    return sign * (degrees + minutes/60.0 + seconds/3600.0)
}

// Find position of character in string - not needed anymore with manual parsing

@astronomical
@3d_transformation
@spherical_geometry
@stellar_mapping
@consciousness_aware
// Calculate 3D coordinates from RA, Dec, and distance
func spherical_to_cartesian(ra_deg: Float, dec_deg: Float, distance: Float) -> Point3D {
    // Convert degrees to radians
    var ra_rad = ra_deg * math.PI / 180.0
    var dec_rad = dec_deg * math.PI / 180.0
    
    // Convert spherical to Cartesian coordinates
    var x = distance * cos(dec_rad) * cos(ra_rad)
    var y = distance * sin(dec_rad)
    var z = distance * cos(dec_rad) * sin(ra_rad)
    
    return Point3D(x, y, z)
}