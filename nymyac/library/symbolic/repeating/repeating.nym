// Repeating Number Classifier for NymyaLang
// Detects and classifies repeating number patterns

import math
import crystal

namespace symbolic {
    namespace repeating {

        // Classification result structure
        class Classification {
            number: Int
            type: String  // "repeated", "palindromic", "mirrored", "fibonacci", "lucas", "power_ten"
            pattern: String
            meaning: String
            traits: List[String]

            init(num: Int, type_str: String, pattern_str: String, meaning_str: String, trait_list: List[String]) {
                this.number = num
                this.type = type_str
                this.pattern = pattern_str
                this.meaning = meaning_str
                this.traits = trait_list
            }
        }

        // Check if a number has all same digits (e.g., 111, 2222)
        func is_repeated_digit(n: Int) -> Bool {
            var num_str = math.abs_int(n).to_string()
            if num_str.length <= 1 {
                return false
            }
            
            var first_digit = num_str[0]
            for i in range(1, num_str.length) {
                if num_str[i] != first_digit {
                    return false
                }
            }
            return true
        }

        // Get meaning for repeated digit numbers
        func get_repeated_meaning(n: Int) -> Classification {
            var num_str = math.abs_int(n).to_string()
            var digit = num_str[0]
            var count = num_str.length
            
            if count == 3 {
                // 3-digit repeats
                if digit == "1" {
                    return Classification(n, "repeated", digit.repeat(count), "initiation surge", 
                        ["initiation", "new_beginning", "surge", "activation"])
                } else if digit == "2" {
                    return Classification(n, "repeated", digit.repeat(count), "alignment of dualities", 
                        ["alignment", "balance", "duality", "harmony"])
                } else if digit == "3" {
                    return Classification(n, "repeated", digit.repeat(count), "amplified creativity", 
                        ["creativity", "expression", "amplification", "synthesis"])
                } else if digit == "4" {
                    return Classification(n, "repeated", digit.repeat(count), "deep structural reinforcement", 
                        ["structure", "stability", "reinforcement", "foundation"])
                } else if digit == "5" {
                    return Classification(n, "repeated", digit.repeat(count), "transformation wave", 
                        ["transformation", "change", "wave", "movement"])
                } else if digit == "6" {
                    return Classification(n, "repeated", digit.repeat(count), "balance under pressure", 
                        ["balance", "pressure", "harmony", "responsibility"])
                } else if digit == "7" {
                    return Classification(n, "repeated", digit.repeat(count), "pattern insight", 
                        ["insight", "pattern", "analysis", "wisdom"])
                } else if digit == "8" {
                    return Classification(n, "repeated", digit.repeat(count), "power continuum", 
                        ["power", "continuity", "manifestation", "abundance"])
                } else if digit == "9" {
                    return Classification(n, "repeated", digit.repeat(count), "completion surge", 
                        ["completion", "transcendence", "surge", "endings"])
                }
            } else if count == 4 {
                // 4-digit repeats
                if digit == "1" {
                    return Classification(n, "repeated", digit.repeat(count), "gateway pattern", 
                        ["gateway", "transition", "initiation", "threshold"])
                } else if digit == "2" {
                    return Classification(n, "repeated", digit.repeat(count), "harmonic alignment", 
                        ["harmony", "alignment", "balance", "cooperation"])
                } else if digit == "3" {
                    return Classification(n, "repeated", digit.repeat(count), "creative amplification", 
                        ["creativity", "amplification", "expression", "synthesis"])
                } else if digit == "4" {
                    return Classification(n, "repeated", digit.repeat(count), "hyper-structure", 
                        ["structure", "organization", "foundation", "stability"])
                } else if digit == "5" {
                    return Classification(n, "repeated", digit.repeat(count), "full-spectrum transformation", 
                        ["transformation", "change", "evolution", "adaptation"])
                } else if digit == "6" {
                    return Classification(n, "repeated", digit.repeat(count), "reinforced equilibrium", 
                        ["balance", "equilibrium", "stability", "harmony"])
                } else if digit == "7" {
                    return Classification(n, "repeated", digit.repeat(count), "deep-pattern recursion", 
                        ["pattern", "recursion", "analysis", "insight"])
                } else if digit == "8" {
                    return Classification(n, "repeated", digit.repeat(count), "infinite expansion", 
                        ["expansion", "infinity", "abundance", "continuity"])
                } else if digit == "9" {
                    return Classification(n, "repeated", digit.repeat(count), "transcendental completion", 
                        ["completion", "transcendence", "universal", "wisdom"])
                }
            }
            
            // Default for other repeated digits
            return Classification(n, "repeated", digit.repeat(count), "repeated digit pattern", 
                ["repetition", "pattern", "amplification", "intensity"])
        }

        // Check if a number is palindromic
        func is_palindromic(n: Int) -> Bool {
            var num_str = math.abs_int(n).to_string()
            var reversed = ""
            for i in range(num_str.length - 1, -1, -1) {
                reversed = reversed + num_str[i]
            }
            return num_str == reversed
        }

        // Get meaning for palindromic numbers
        func get_palindromic_meaning(n: Int) -> Classification {
            var traits = ["balance", "reflection", "symmetry", "harmony"]
            var meaning = "palindromic balance, reflection and symmetry"
            
            // Add meaning based on the number's base numerology
            var base_num = get_base_number(n)
            if base_num == 1 {
                meaning = "palindromic origin and individual reflection"
                traits.append("initiation")
            } else if base_num == 2 {
                meaning = "palindromic duality and relational balance"
                traits.append("partnership")
            } else if base_num == 3 {
                meaning = "palindromic creative expression and synthesis"
                traits.append("creativity")
            } else if base_num == 6 {
                meaning = "palindromic harmony and nurturing balance"
                traits.append("nurturing")
            } else if base_num == 8 {
                meaning = "palindromic manifestation and infinite continuity"
                traits.append("manifestation")
            }
            
            return Classification(n, "palindromic", "palindrome", meaning, traits)
        }

        // Get base numerology number
        func get_base_number(n: Int) -> Int {
            var num = math.abs_int(n)
            var digit_sum = 0
            while num > 0 {
                digit_sum = digit_sum + (num % 10)
                num = num / 10
            }
            
            // If the sum is 11, 22, or 33, return those master numbers
            if digit_sum == 11 or digit_sum == 22 or digit_sum == 33 {
                return digit_sum
            }
            
            // Otherwise, continue reducing
            if digit_sum > 9 {
                return get_base_number(digit_sum)
            }
            
            return digit_sum
        }

        // Check if number is mirrored (like 1221, 3443)
        func is_mirrored(n: Int) -> Bool {
            var num_str = math.abs_int(n).to_string()
            if num_str.length % 2 != 0 {
                return false  // Only even length numbers can be mirrored
            }
            
            var mid = num_str.length / 2
            var first_half = ""
            var second_half = ""
            
            for i in range(mid) {
                first_half = first_half + num_str[i]
            }
            for i in range(mid, num_str.length) {
                second_half = second_half + num_str[i]
            }
            
            var reversed_second = ""
            for i in range(second_half.length - 1, -1, -1) {
                reversed_second = reversed_second + second_half[i]
            }
            
            return first_half == reversed_second
        }

        // Get meaning for mirrored numbers
        func get_mirrored_meaning(n: Int) -> Classification {
            var traits = ["balance", "reflection", "symmetry", "integration"]
            var meaning = "mirrored pattern, balance and reflection"
            
            var base_num = get_base_number(n)
            if base_num == 1 {
                meaning = "mirrored origin and self-reflection"
                traits.append("self-awareness")
            } else if base_num == 2 {
                meaning = "mirrored duality and partnership balance"
                traits.append("partnership")
            } else if base_num == 6 {
                meaning = "mirrored harmony and nurturing balance"
                traits.append("nurturing")
            } else if base_num == 8 {
                meaning = "mirrored manifestation and abundance reflection"
                traits.append("manifestation")
            }
            
            return Classification(n, "mirrored", "mirror", meaning, traits)
        }

        // Fibonacci sequence detection
        func is_fibonacci(n: Int) -> Bool {
            if n < 0 {
                return false
            }
            
            if n == 0 or n == 1 {
                return true
            }
            
            var a = 0
            var b = 1
            var c = a + b
            
            while c < n {
                a = b
                b = c
                c = a + b
            }
            
            return c == n
        }

        // Lucas sequence detection
        func is_lucas(n: Int) -> Bool {
            if n < 0 {
                return false
            }
            
            if n == 2 or n == 1 {
                return true
            }
            
            var a = 2
            var b = 1
            var c = a + b
            
            while c < n {
                a = b
                b = c
                c = a + b
            }
            
            return c == n
        }

        // Power of ten sequence detection
        func is_power_of_ten(n: Int) -> Bool {
            if n <= 0 {
                return false
            }
            
            var num = n
            while num % 10 == 0 and num > 1 {
                num = num / 10
            }
            
            return num == 1
        }

        // Classify any number
        func classify(n: Int) -> Classification {
            // Check for repeated digits first
            if is_repeated_digit(n) {
                return get_repeated_meaning(n)
            }
            
            // Check for palindromic
            if is_palindromic(n) {
                return get_palindromic_meaning(n)
            }
            
            // Check for mirrored
            if is_mirrored(n) {
                return get_mirrored_meaning(n)
            }
            
            // Check for power of ten
            if is_power_of_ten(n) {
                return Classification(n, "power_ten", "power_of_ten", 
                    "power sequence and expansion", 
                    ["expansion", "power", "sequence", "growth"])
            }
            
            // Check for Fibonacci
            if is_fibonacci(n) {
                return Classification(n, "fibonacci", "fibonacci", 
                    "natural growth pattern and golden ratio connection", 
                    ["growth", "natural", "golden_ratio", "expansion"])
            }
            
            // Check for Lucas
            if is_lucas(n) {
                return Classification(n, "lucas", "lucas", 
                    "complementary growth pattern to Fibonacci", 
                    ["growth", "complementary", "natural", "pattern"])
            }
            
            // Default classification
            return Classification(n, "standard", "standard", 
                "standard number without special repeating pattern", 
                ["standard", "ordinary", "basic"])
        }

        // Get all classifications for a number
        func get_all_classifications(n: Int) -> List[Classification] {
            var results = []
            
            // Add the primary classification
            results.append(classify(n))
            
            // Check for multiple classifications
            if is_palindromic(n) and is_fibonacci(n) {
                results.append(Classification(n, "palindromic_fibonacci", "both", 
                    "both palindromic and fibonacci", 
                    ["palindromic", "fibonacci", "natural", "symmetric"]))
            }
            
            if is_repeated_digit(n) and is_fibonacci(n) {
                results.append(Classification(n, "repeated_fibonacci", "both", 
                    "both repeated digit and fibonacci", 
                    ["repeated", "fibonacci", "pattern", "natural"]))
            }
            
            return results
        }
    }
}