// Prime Number Symbolism for NymyaLang
// Implements prime classification and symbolic meanings

import math
import crystal

namespace symbolic {
    namespace primes {

        // Prime classification structure
        class PrimeSymbol {
            value: Int
            is_prime: Bool
            classification: String  // "twin", "mersenne", "regular", "large"
            symbolic_meaning: String
            traits: List[String]
            special_properties: List[String]

            init(val: Int, is_prime_val: Bool, class: String, meaning: String, 
                 trait_list: List[String], properties: List[String]) {
                this.value = val
                this.is_prime = is_prime_val
                this.classification = class
                this.symbolic_meaning = meaning
                this.traits = trait_list
                this.special_properties = properties
            }
        }

        // Check if a number is prime
        func is_prime(n: Int) -> Bool {
            if n <= 1 {
                return false
            }
            if n <= 3 {
                return true
            }
            if n % 2 == 0 or n % 3 == 0 {
                return false
            }
            
            var i = 5
            while i * i <= n {
                if n % i == 0 or n % (i + 2) == 0 {
                    return false
                }
                i = i + 6
            }
            
            return true
        }

        // Check if a number is a Mersenne prime (2^p - 1 where p is also prime)
        func is_mersenne_prime(n: Int) -> Bool {
            if not is_prime(n) {
                return false
            }
            
            // A Mersenne prime has the form 2^p - 1
            var candidate_p = 0
            var temp = n + 1
            var power = 0
            
            // Check if n+1 is a power of 2
            while temp > 1 {
                if temp % 2 != 0 {
                    return false  // Not a power of 2
                }
                temp = temp / 2
                power = power + 1
            }
            
            // If n+1 is 2^p, then n is 2^p - 1
            // Check if p is prime
            return is_prime(power)
        }

        // Check if two primes are twin primes (differ by 2)
        func are_twin_primes(p1: Int, p2: Int) -> Bool {
            return (is_prime(p1) and is_prime(p2) and math.abs_int(p1 - p2) == 2)
        }

        // Get the classification for a prime number
        func get_prime_classification(n: Int) -> String {
            if not is_prime(n) {
                return "composite"
            }
            
            // Check for special prime types
            if is_mersenne_prime(n) {
                return "mersenne"
            }
            
            // Check if it's part of a twin prime pair
            if are_twin_primes(n, n - 2) or are_twin_primes(n, n + 2) {
                return "twin"
            }
            
            // Large primes (over 100) get a "large" classification
            if n > 100 {
                return "large"
            }
            
            return "regular"
        }

        // Get symbolic meaning for a prime number
        func get_prime_symbol(n: Int) -> PrimeSymbol {
            if not is_prime(n) {
                return PrimeSymbol(n, false, "composite", 
                    "composite number, reducible and not prime", 
                    ["reducible", "composite", "factorable"], ["not_prime"])
            }
            
            var classification = get_prime_classification(n)
            var meaning = ""
            var traits = []
            var properties = []
            
            // Default meaning for regular primes
            meaning = "indivisible pattern, prime foundation, unique mathematical essence"
            traits = ["indivisible", "foundation", "unique", "essential", "irreducible"]
            properties = ["prime", "not_factorable"]
            
            if classification == "twin" {
                meaning = "polarity harmonic in twin prime pair, duality balance"
                traits = ["harmonic", "polarity", "balance", "duality", "paired"]
                properties = ["prime", "twin"]
            } else if classification == "mersenne" {
                meaning = "compression signature, Mersenne prime with deep mathematical structure"
                traits = ["compression", "signature", "deep_structure", "mathematical", "rare"]
                properties = ["prime", "mersenne"]
            } else if classification == "large" {
                meaning = "irreducible complexity, large prime with unique pattern"
                traits = ["complexity", "irreducible", "large", "unique", "pattern"]
                properties = ["prime", "large"]
            }
            
            // Special meanings for key primes
            if n == 2 {
                meaning = "first prime, beginning of primes, even prime singularity"
                traits = ["first", "beginning", "even", "singularity", "foundation"]
                properties = ["prime", "smallest", "even"]
            } else if n == 3 {
                meaning = "divine trinity prime, first odd prime"
                traits = ["divine", "trinity", "first_odd", "creative", "triangular"]
                properties = ["prime", "divine", "trinity"]
            } else if n == 5 {
                meaning = "life force prime, golden ratio connection, pentagonal"
                traits = ["life_force", "golden_ratio", "pentagonal", "natural", "flow"]
                properties = ["prime", "golden", "life_force"]
            } else if n == 7 {
                meaning = "mystical prime, completion, spiritual significance"
                traits = ["mystical", "completion", "spiritual", "hidden", "lucky"]
                properties = ["prime", "mystical", "lucky"]
            } else if n == 11 {
                meaning = "master number prime, illumination, intensity"
                traits = ["illumination", "intensity", "master", "double", "amplified"]
                properties = ["prime", "master_number", "double"]
            } else if n == 13 {
                meaning = "transformation prime, change, rebirth"
                traits = ["transformation", "change", "rebirth", "transition", "cycle"]
                properties = ["prime", "transformation", "change"]
            } else if n == 17 {
                meaning = "vortex prime, combination of 1 and 7 (unity and introspection)"
                traits = ["vortex", "combination", "balance", "mystical", "powerful"]
                properties = ["prime", "vortex", "combination"]
            } else if n == 19 {
                meaning = "fractal expansion prime, flower of life connection"
                traits = ["fractal", "expansion", "flower_of_life", "symmetry", "growth"]
                properties = ["prime", "fractal", "flower_of_life"]
            } else if n == 23 {
                meaning = "chaotic attractor prime, significant in chaos theory"
                traits = ["chaos", "attractor", "significant", "complexity", "non_linear"]
                properties = ["prime", "chaos", "attractor"]
            } else if n == 37 {
                meaning = "recursion prime, pattern seed and mathematical beauty"
                traits = ["recursion", "pattern", "beauty", "mathematical", "seed"]
                properties = ["prime", "recursion", "pattern"]
            }
            
            return PrimeSymbol(n, true, classification, meaning, traits, properties)
        }

        // Get list of primes up to n
        func primes_up_to(n: Int) -> List[Int] {
            var primes = []
            for i in range(2, n + 1) {
                if is_prime(i) {
                    primes.append(i)
                }
            }
            return primes
        }

        // Get twin primes up to n
        func twin_primes_up_to(n: Int) -> List[List[Int]] {
            var twin_primes = []
            var primes = primes_up_to(n)
            
            for i in range(primes.length - 1) {
                if primes[i+1] - primes[i] == 2 {
                    twin_primes.append([primes[i], primes[i+1]])
                }
            }
            
            return twin_primes
        }

        // Get Mersenne primes up to n
        func mersenne_primes_up_to(n: Int) -> List[Int] {
            var mersenne_primes = []
            var candidate = 2
            var power = 1
            
            while true {
                var mersenne = math.pow_int(2, power) - 1
                if mersenne > n {
                    break
                }
                
                if is_prime(mersenne) {
                    mersenne_primes.append(mersenne)
                }
                
                power = power + 1
            }
            
            return mersenne_primes
        }

        // Main function to classify any number for primality
        func prime_class(n: Int) -> PrimeSymbol {
            return get_prime_symbol(n)
        }

        // Get detailed prime analysis
        func prime_analysis(n: Int) -> List[PrimeSymbol] {
            var results = []
            
            // Add the main classification
            results.append(prime_class(n))
            
            // If it's a twin prime, also show its twin
            if is_prime(n) {
                if is_prime(n - 2) {
                    results.append(get_prime_symbol(n - 2))
                }
                if is_prime(n + 2) {
                    results.append(get_prime_symbol(n + 2))
                }
            }
            
            return results
        }
    }
}