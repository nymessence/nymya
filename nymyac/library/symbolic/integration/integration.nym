// Integration Engine for NymyaLang Symbolic Mathematics
// Merges numerology, repeating sequences, special numbers, primes, and sacred geometry

import math
import crystal
import symbolic.numerology
import symbolic.repeating
import symbolic.special
import symbolic.primes
import symbolic.sacred_geometry

namespace symbolic {
    namespace integration {

        // Integrated symbolic meaning structure
        class IntegratedSymbol {
            number: Int
            numerology_meanings: List[numerology.SymbolicMeaning]
            repeating_classifications: List[repeating.Classification]
            special_meaning: special.SpecialNumber
            prime_symbol: primes.PrimeSymbol
            geometry_correspondences: List[sacred_geometry.SacredGeometry]

            init(num: Int) {
                this.number = num
                this.numerology_meanings = []
                this.repeating_classifications = []
                this.special_meaning = special.SpecialNumber(0, "", "", [], "", [])
                this.prime_symbol = primes.PrimeSymbol(0, false, "", "", [], [])
                this.geometry_correspondences = []
            }
        }

        // Get integrated meaning for a number
        func get_symbolic(n: Int) -> IntegratedSymbol {
            var result = IntegratedSymbol(n)
            
            // Add numerology meanings
            result.numerology_meanings = numerology.get_full_analysis(n)
            
            // Add repeating classifications
            result.repeating_classifications = repeating.get_all_classifications(n)
            
            // Add special number meaning
            result.special_meaning = special.get_comprehensive_meaning(n)
            
            // Add prime symbol
            result.prime_symbol = primes.prime_class(n)
            
            // Add geometry correspondences
            result.geometry_correspondences = sacred_geometry.find_geometries_for_number(math.abs_int(n))
            
            return result
        }

        // Describe the symbolic meaning of a number in human-readable form
        func describe(n: Int) -> String {
            var integrated = get_symbolic(n)
            var description = "Symbolic analysis for " + n + ":\n"
            
            // Add numerology
            description = description + "Numerology:\n"
            for meaning in integrated.numerology_meanings {
                description = description + "  - Base: " + meaning.meaning + "\n"
                description = description + "    Traits: " + meaning.traits.join(", ") + "\n"
            }
            
            // Add repeating patterns
            description = description + "Repeating patterns:\n"
            for classification in integrated.repeating_classifications {
                description = description + "  - " + classification.type + ": " + classification.meaning + "\n"
                description = description + "    Traits: " + classification.traits.join(", ") + "\n"
            }
            
            // Add special number meaning
            if integrated.special_meaning.category != "standard" {
                description = description + "Special number:\n"
                description = description + "  - " + integrated.special_meaning.name + ": " + integrated.special_meaning.meaning + "\n"
                description = description + "    Category: " + integrated.special_meaning.category + "\n"
                description = description + "    Traits: " + integrated.special_meaning.traits.join(", ") + "\n"
            }
            
            // Add prime information
            if integrated.prime_symbol.is_prime {
                description = description + "Prime classification:\n"
                description = description + "  - " + integrated.prime_symbol.classification + ": " + integrated.prime_symbol.symbolic_meaning + "\n"
                description = description + "    Traits: " + integrated.prime_symbol.traits.join(", ") + "\n"
            }
            
            // Add geometry correspondences
            if integrated.geometry_correspondences.length > 0 {
                description = description + "Sacred geometry correspondences:\n"
                for geometry in integrated.geometry_correspondences {
                    description = description + "  - " + geometry.name + ": " + geometry.symbolic_meaning + "\n"
                    description = description + "    Numeral links: " + geometry.numeric_correspondences.join(", ") + "\n"
                }
            }
            
            return description
        }

        // Get overlays based on number properties
        func overlays(n: Int) -> List[String] {
            var overlays = []
            var abs_n = math.abs_int(n)
            
            // Add geometry overlays based on number
            var geometries = sacred_geometry.find_geometries_for_number(abs_n)
            for geometry in geometries {
                overlays.append(geometry.id)
            }
            
            // Add special overlays for specific numbers
            if abs_n == 369 {
                overlays.append("star_tetrahedron_overlay")  // 3, 6, 9 trigger star tetrahedron
            }
            
            if abs_n == 144 {
                overlays.append("flower_of_life_resonance")  // 144 triggers flower of life
            }
            
            if abs_n == 88 or abs_n == 888 {
                overlays.append("torus_flow_semantics")  // 88/888 trigger torus flow
            }
            
            // Check if it's a Fibonacci number for phi-spiral overlay
            if repeating.is_fibonacci(abs_n) {
                overlays.append("phi_spiral_overlay")
            }
            
            return overlays
        }

        // Apply overlays to a base meaning
        func apply_overlays(base_meaning: String, n: Int) -> String {
            var result = base_meaning
            var overlay_list = overlays(n)
            
            for overlay in overlay_list {
                if overlay == "star_tetrahedron_overlay" {
                    result = result + " [Enhanced with star-tetrahedron dual-field dynamics]"
                } else if overlay == "flower_of_life_resonance" {
                    result = result + " [Resonating with flower-of-life harmonic grid]"
                } else if overlay == "torus_flow_semantics" {
                    result = result + " [Incorporating torus-field flow semantics]"
                } else if overlay == "phi_spiral_overlay" {
                    result = result + " [Enhanced with golden-ratio spiral dynamics]"
                }
            }
            
            return result
        }

        // Complex pattern detection
        func detect_complex_patterns(n: Int) -> List[String] {
            var patterns = []
            var abs_n = math.abs_int(n)
            
            // Check for combinations that create complex patterns
            if repeating.is_fibonacci(abs_n) and repeating.is_palindromic(abs_n) {
                patterns.append("fibonacci_palindrome_harmony")
            }
            
            if repeating.is_repeated_digit(abs_n) and special.is_special_number(abs_n) {
                patterns.append("repeated_special_amplification")
            }
            
            if primes.is_prime(abs_n) and repeating.is_palindromic(abs_n) {
                patterns.append("prime_palindrome_mystique")
            }
            
            if sacred_geometry.has_geometric_significance(abs_n) and special.is_special_number(abs_n) {
                patterns.append("geometric_special_resonance")
            }
            
            // Check for 369 pattern (vortex mathematics)
            if abs_n % 3 == 0 and abs_n % 6 == 0 and abs_n % 9 == 0 {
                patterns.append("vortex_key_pattern")
            }
            
            return patterns
        }

        // Comprehensive symbolic analysis
        func comprehensive_analysis(n: Int) -> String {
            var integrated = get_symbolic(n)
            var analysis = "Comprehensive symbolic analysis for " + n + ":\n"
            
            // Basic info
            analysis = analysis + "Number: " + n + "\n"
            analysis = analysis + "Absolute value: " + math.abs_int(n) + "\n"
            analysis = analysis + "Base numerology: " + numerology.reduce_to_base(math.abs_int(n)) + "\n"
            
            // Complex patterns
            var complex_patterns = detect_complex_patterns(n)
            if complex_patterns.length > 0 {
                analysis = analysis + "Complex patterns detected: " + complex_patterns.join(", ") + "\n"
            }
            
            // Overlays
            var overlay_list = overlays(n)
            if overlay_list.length > 0 {
                analysis = analysis + "Applied overlays: " + overlay_list.join(", ") + "\n"
            }
            
            analysis = analysis + "\n" + describe(n)
            
            return analysis
        }

        // Get all traits for a number (useful for downstream processing)
        func get_all_traits(n: Int) -> List[String] {
            var traits = []
            var integrated = get_symbolic(n)
            
            // Add numerology traits
            for meaning in integrated.numerology_meanings {
                traits = traits + meaning.traits
            }
            
            // Add repeating classification traits
            for classification in integrated.repeating_classifications {
                traits = traits + classification.traits
            }
            
            // Add special number traits
            traits = traits + integrated.special_meaning.traits
            
            // Add prime traits
            traits = traits + integrated.prime_symbol.traits
            
            // Remove duplicates
            var unique_traits = []
            for trait in traits {
                if not contains(unique_traits, trait) {
                    unique_traits.append(trait)
                }
            }
            
            return unique_traits
        }

        // Helper to check if a list contains a string
        func contains(list: List[String], item: String) -> Bool {
            for element in list {
                if element == item {
                    return true
                }
            }
            return false
        }

        // High-level function that wraps all symbolic functionality
        func get_full_symbolic_info(n: Int) -> IntegratedSymbol {
            return get_symbolic(n)
        }
    }
}