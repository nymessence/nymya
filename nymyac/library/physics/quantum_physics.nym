// Quantum Physics Equations Library for NymyaLang
// Implements quantum mechanical equations from the quantum equations wiki file
// Provides access to fundamental quantum physics formulas and operations

import math
import crystal
import quantum

namespace physics {
    namespace quantum {

        // Fundamental constants
        val H_BAR: Float = 1.054571817e-34  // Reduced Planck constant (ħ)
        val PLANCK_CONSTANT: Float = 6.62607015e-34  // Planck constant (h)
        val SPEED_OF_LIGHT: Float = 299792458.0  // Speed of light (c) in m/s
        val ELECTRON_CHARGE: Float = 1.602176634e-19  // Elementary charge (e) in Coulombs
        val ELECTRON_MASS: Float = 9.1093837015e-31  // Electron mass (me) in kg
        val BOHR_MAGNETON: Float = 9.2740100783e-24  // Bohr magneton (μB) in J/T
        val PERMITTIVITY_VACUUM: Float = 8.8541878128e-12  // ε₀ in F/m
        val EV_TO_JOULE: Float = 1.602176634e-19  // Conversion from eV to Joules

        // Wavefunction-related functions

        // Calculate probability density from wavefunction: |Ψ|² = Ψ*Ψ
        func probability_density(wavefunction_real: Float, wavefunction_imag: Float) -> Float {
            var psi_star_real = wavefunction_real  // Complex conjugate: real part stays same
            var psi_star_imag = -wavefunction_imag  // Complex conjugate: imaginary part gets negated
            
            // |Ψ|² = Ψ* · Ψ = (ψ_real - i*ψ_imag) * (ψ_real + i*ψ_imag) = ψ_real² + ψ_imag²
            return wavefunction_real * wavefunction_real + wavefunction_imag * wavefunction_imag
        }

        // Quantum probability current density calculation in 3D
        func probability_current(wavefunction: List[math.Complex], grad_wavefunction: List[math.Complex], mass: Float) -> List[Float] {
            // j = (ħ/2mi)[Ψ*∇Ψ - Ψ∇Ψ*] = (ħ/m) Im(Ψ*∇Ψ)
            var h_bar_over_m = H_BAR / mass
            
            // Calculate Im(Ψ*∇Ψ) for each component (x, y, z)
            var current_density = []
            for i in range(3) {  // 3D case
                var psi = wavefunction[i]
                var grad_psi = grad_wavefunction[i]
                
                // Calculate Ψ* · ∇Ψ
                var psi_conj = math.Complex(psi.real, -psi.imag)  // Complex conjugate
                var product = psi_conj.multiply(grad_psi)  // Ψ* · ∇Ψ
                
                // Take imaginary part: Im(Ψ*∇Ψ)
                var im_part = product.imag
                
                // Current density = (ħ/m) * Im(Ψ*∇Ψ)
                var component = h_bar_over_m * im_part
                current_density.append(component)
            }
            
            return current_density
        }

        // Position-momentum Fourier transform (simplified for 1D)
        func position_to_momentum_space(position_wavefunction: List[Float], momentum_points: List[Float], position_points: List[Float]) -> List[Float] {
            // Φ(p) = (1/√(2πħ)) ∫ e^(-ip·r/ħ) Ψ(r) dr
            var normalization = 1.0 / math.sqrt(2.0 * math.PI * H_BAR)
            var momentum_wavefunction = []
            
            for p in momentum_points {
                var integral_sum = math.Complex(0.0, 0.0)
                
                for i in range(position_points.length) {
                    var r = position_points[i]
                    var psi_r = position_wavefunction[i]
                    
                    // Calculate e^(-ip·r/ħ)
                    var phase = -p * r / H_BAR
                    var exp_factor = math.Complex(math.cos(phase), math.sin(phase))
                    
                    // Add contribution: e^(-ip·r/ħ) * Ψ(r)
                    var contribution = exp_factor.multiply(math.Complex(psi_r, 0.0))
                    integral_sum = integral_sum.add(contribution)
                }
                
                // Apply normalization and store magnitude (absolute value)
                var result = normalization * integral_sum.magnitude()
                momentum_wavefunction.append(result)
            }
            
            return momentum_wavefunction
        }

        // Momentum to position space Fourier transform
        func momentum_to_position_space(momentum_wavefunction: List[Float], position_points: List[Float], momentum_points: List[Float]) -> List[Float] {
            // Ψ(r) = (1/√(2πħ)) ∫ e^(+ip·r/ħ) Φ(p) dp
            var normalization = 1.0 / math.sqrt(2.0 * math.PI * H_BAR)
            var position_wavefunction = []
            
            for r in position_points {
                var integral_sum = math.Complex(0.0, 0.0)
                
                for i in range(momentum_points.length) {
                    var p = momentum_points[i]
                    var phi_p = momentum_wavefunction[i]
                    
                    // Calculate e^(+ip·r/ħ)
                    var phase = p * r / H_BAR
                    var exp_factor = math.Complex(math.cos(phase), math.sin(phase))
                    
                    // Add contribution: e^(+ip·r/ħ) * Φ(p)
                    var contribution = exp_factor.multiply(math.Complex(phi_p, 0.0))
                    integral_sum = integral_sum.add(contribution)
                }
                
                // Apply normalization and store magnitude (absolute value)
                var result = normalization * integral_sum.magnitude()
                position_wavefunction.append(result)
            }
            
            return position_wavefunction
        }

        // Quantum mechanics operators and equations

        // Energy-momentum relation from Planck-Einstein and de Broglie relations
        func energy_momentum_relation(energy: Float, momentum_magnitude: Float) -> Bool {
            // E = ħω, p = ħk, so E = pc for photons, E² = p²c² + m²c⁴ for massive particles
            var expected_energy = math.sqrt(momentum_magnitude * momentum_magnitude * SPEED_OF_LIGHT * SPEED_OF_LIGHT + 0.0)  // Assuming massless for simplicity
            var tolerance = 1e-10
            return math.abs(energy - expected_energy) < tolerance
        }

        // Schrödinger equation components

        // Time-independent Schrödinger equation: Ĥψ = Eψ
        // For a 1D system with potential V(x)
        func schrodinger_hamiltonian_1d(wavefunction: List[Float], x_coords: List[Float], mass: Float, potential_func: Func[Float, Float]) -> List[Float] {
            // Ĥ = -ħ²/2m ∇² + V(x)
            var hbar_squared_over_2m = -(H_BAR * H_BAR) / (2.0 * mass)
            var result = []
            
            // For discretized system, we approximate ∇² using finite differences
            var dx = if x_coords.length > 1 { x_coords[1] - x_coords[0] } else { 0.01 }  // Default spacing
            
            for i in range(wavefunction.length) {
                var laplacian_approx = 0.0
                
                // Central difference for second derivative: (ψ[i+1] - 2*ψ[i] + ψ[i-1]) / dx²
                if i > 0 and i < wavefunction.length - 1 {
                    laplacian_approx = (wavefunction[i+1] - 2.0 * wavefunction[i] + wavefunction[i-1]) / (dx * dx)
                } else if i == 0 {
                    // Forward difference at boundary: (ψ[1] - 2*ψ[0] + ψ[fake_prev])
                    var fake_prev = if wavefunction.length > 1 { wavefunction[0] } else { 0.0 }  // Boundary condition
                    laplacian_approx = (wavefunction[1] - 2.0 * wavefunction[0] + fake_prev) / (dx * dx)
                } else {  // i == length - 1
                    // Backward difference at boundary: (ψ[fake_next] - 2*ψ[end] + ψ[end-1])
                    var fake_next = if wavefunction.length > 1 { wavefunction[wavefunction.length-1] } else { 0.0 }  // Boundary condition
                    laplacian_approx = (fake_next - 2.0 * wavefunction[i] + wavefunction[i-1]) / (dx * dx)
                }
                
                var x = x_coords[i]
                var potential_energy = potential_func(x)
                
                // Ĥψ = (-ħ²/2m) * ∇²ψ + V(x) * ψ
                var hamiltonian_result = hbar_squared_over_2m * laplacian_approx + potential_energy * wavefunction[i]
                result.append(hamiltonian_result)
            }
            
            return result
        }

        // Time-dependent Schrödinger equation: iħ ∂ψ/∂t = Ĥψ
        func time_evolution_step(initial_wavefunction: List[math.Complex], hamiltonian_matrix: List[List[math.Complex]], time_step: Float) -> List[math.Complex] {
            // Solve: ∂ψ/∂t = -i/ħ Ĥψ
            // For small time step: ψ(t+dt) ≈ ψ(t) + dt * (-i/ħ * Ĥ * ψ(t))
            
            var ihbar_inv = math.Complex(0.0, -1.0) / H_BAR  // -i/ħ
            
            var result = []
            for i in range(initial_wavefunction.length) {
                var hamiltonian_action = math.Complex(0.0, 0.0)
                
                // Calculate (Ĥ * ψ)_i = Σ_j H_ij * ψ_j
                for j in range(initial_wavefunction.length) {
                    var h_element = hamiltonian_matrix[i][j]
                    var psi_element = initial_wavefunction[j]
                    var product = h_element.multiply(psi_element)
                    hamiltonian_action = hamiltonian_action.add(product)
                }
                
                // Calculate time derivative: dψ/dt = (-i/ħ) * (Ĥ * ψ)
                var time_derivative = ihbar_inv.multiply(hamiltonian_action)
                
                // Calculate next time step: ψ_new = ψ_old + dt * dψ/dt
                var psi_new = initial_wavefunction[i].add(time_derivative.multiply_scalar(time_step))
                result.append(psi_new)
            }
            
            return result
        }

        // Uncertainty Relations

        // Calculate uncertainty (standard deviation) of an observable
        func calculate_uncertainty(observable_values: List[Float], probabilities: List[Float]) -> Float {
            // σ(A)² = ⟨A²⟩ - ⟨A⟩²
            // ⟨A⟩ = Σ_i prob_i * A_i
            // ⟨A²⟩ = Σ_i prob_i * A_i²
            
            if observable_values.length != probabilities.length {
                crystal.manifest("Error: Values and probabilities must have the same length")
                return 0.0
            }
            
            var avg_a = 0.0
            var avg_a_squared = 0.0
            
            for i in range(observable_values.length) {
                avg_a = avg_a + probabilities[i] * observable_values[i]
                avg_a_squared = avg_a_squared + probabilities[i] * observable_values[i] * observable_values[i]
            }
            
            var variance = avg_a_squared - avg_a * avg_a
            return math.sqrt(math.abs(variance))  // Ensure non-negative
        }

        // Heisenberg uncertainty relation: σ(x) * σ(p) ≥ ℏ/2
        func heisenberg_uncertainty(position_uncertainty: Float, momentum_uncertainty: Float) -> Bool {
            var product = position_uncertainty * momentum_uncertainty
            var min_uncertainty = H_BAR / 2.0
            return product >= min_uncertainty
        }

        // General uncertainty relation: σ(A)σ(B) ≥ |⟨[A,B]⟩|/2
        func general_uncertainty(operators_commutator: Float, avg_commutator: Float) -> Float {
            // For Hermitian operators A, B: σ(A)σ(B) ≥ |⟨[A,B]⟩|/2
            return math.abs(avg_commutator) / 2.0
        }

        // Photoelectric effect equations

        // Calculate maximum kinetic energy: K_max = hf - φ
        func photoelectric_effect_max_kinetic_energy(photon_frequency: Float, work_function: Float) -> Float {
            var photon_energy = PLANCK_CONSTANT * photon_frequency
            var max_kinetic_energy = photon_energy - work_function
            return math.max(0.0, max_kinetic_energy)  // Kinetic energy can't be negative
        }

        // Calculate threshold frequency: f_0 = φ/h
        func photoelectric_threshold_frequency(work_function: Float) -> Float {
            return work_function / PLANCK_CONSTANT
        }

        // Calculate photon momentum: p = h/λ = hf/c
        func photon_momentum(frequency: Float) -> Float {
            return PLANCK_CONSTANT * frequency / SPEED_OF_LIGHT
        }

        func photon_momentum_from_wavelength(wavelength: Float) -> Float {
            return PLANCK_CONSTANT / wavelength
        }

        // Angular momentum operators and quantum numbers

        // Calculate spin angular momentum magnitude: |S| = ħ√(s(s+1))
        func spin_magnitude(spin_quantum_number: Float) -> Float {
            return H_BAR * math.sqrt(spin_quantum_number * (spin_quantum_number + 1.0))
        }

        // Calculate orbital angular momentum magnitude: |L| = ħ√(ℓ(ℓ+1))
        func orbital_angular_momentum_magnitude(angular_momentum_quantum_number: Float) -> Float {
            return H_BAR * math.sqrt(angular_momentum_quantum_number * (angular_momentum_quantum_number + 1.0))
        }

        // Calculate total angular momentum magnitude: |J| = ħ√(j(j+1))
        func total_angular_momentum_magnitude(total_angular_momentum_quantum_number: Float) -> Float {
            return H_BAR * math.sqrt(total_angular_momentum_quantum_number * (total_angular_momentum_quantum_number + 1.0))
        }

        // Calculate z-component of angular momentum: Lz = m_ℓħ
        func angular_momentum_z_component(magnetic_quantum_number: Float) -> Float {
            return H_BAR * magnetic_quantum_number
        }

        // Magnetic moments

        // Calculate orbital magnetic dipole moment: μ_ℓ = -eL/2m_e = g_ℓ(μB/ħ)L
        func orbital_magnetic_moment(orbital_angular_momentum: Float, g_factor: Float) -> Float {
            var prefactor = g_factor * BOHR_MAGNETON / H_BAR
            return -prefactor * orbital_angular_momentum
        }

        // Calculate z-component: μ_ℓ,z = -m_ℓμB
        func orbital_magnetic_moment_z_component(magnetic_quantum_number: Float) -> Float {
            return -magnetic_quantum_number * BOHR_MAGNETON
        }

        // Calculate spin magnetic dipole moment: μ_s = -eS/m_e = g_s(μB/ħ)S
        func spin_magnetic_moment(spin_angular_momentum: Float, g_factor: Float) -> Float {
            var prefactor = g_factor * BOHR_MAGNETON / H_BAR
            return -prefactor * spin_angular_momentum
        }

        // Calculate potential energy of magnetic dipole in field: U = -μ·B
        func magnetic_dipole_potential_energy(magnetic_moment: Float, magnetic_field_strength: Float, angle: Float) -> Float {
            // U = -μ·B = -μB cos(θ)
            return -magnetic_moment * magnetic_field_strength * math.cos(angle)
        }

        // Hydrogen atom solutions

        // Calculate hydrogen atom energy levels: E_n = -13.61 eV / n²
        func hydrogen_energy_level(principal_quantum_number: Int) -> Float {
            if principal_quantum_number <= 0 {
                crystal.manifest("Error: Principal quantum number must be positive")
                return 0.0
            }
            
            var n_squared = principal_quantum_number.toFloat() * principal_quantum_number.toFloat()
            var energy_ev = -13.61 / n_squared  // Energy in electron volts
            return energy_ev * EV_TO_JOULE  // Convert to Joules
        }

        // Calculate Rydberg formula for spectral lines: 1/λ = R(1/n_j² - 1/n_i²)
        func hydrogen_spectral_line(initial_level: Int, final_level: Int) -> Float {
            if final_level >= initial_level or initial_level <= 0 or final_level <= 0 {
                crystal.manifest("Error: Invalid quantum level transition")
                return 0.0
            }
            
            var rydberg_constant = 1.0973731568508e7  // Rydberg constant in m⁻¹
            var n_i_sq = initial_level.toFloat() * initial_level.toFloat()
            var n_j_sq = final_level.toFloat() * final_level.toFloat()
            
            var inv_wavelength = rydberg_constant * (1.0/n_j_sq - 1.0/n_i_sq)
            return 1.0 / inv_wavelength  // Wavelength in meters
        }

        // Quantum statistics distributions

        // Fermi-Dirac distribution: P(E) = 1/(e^((E-μ)/kT) + 1)
        func fermi_dirac_distribution(energy: Float, chemical_potential: Float, temperature: Float) -> Float {
            if temperature <= 0.0 {
                crystal.manifest("Error: Temperature must be positive")
                return 0.0
            }
            
            var k_boltzmann = 1.380649e-23  // Boltzmann constant
            var exponent = (energy - chemical_potential) / (k_boltzmann * temperature)
            
            if exponent > 700.0 {  // Prevent overflow
                return 0.0  // Approaches 0 for large exponent
            } else if exponent < -700.0 {  // Prevent underflow
                return 1.0  // Approaches 1 for negative large exponent
            }
            
            var exp_value = math.exp(exponent)
            return 1.0 / (exp_value + 1.0)
        }

        // Bose-Einstein distribution: P(E) = 1/(e^((E-μ)/kT) - 1)
        func bose_einstein_distribution(energy: Float, chemical_potential: Float, temperature: Float) -> Float {
            if temperature <= 0.0 {
                crystal.manifest("Error: Temperature must be positive")
                return 0.0
            }
            
            var k_boltzmann = 1.380649e-23  // Boltzmann constant
            var exponent = (energy - chemical_potential) / (k_boltzmann * temperature)
            
            if exponent > 700.0 {  // Prevent overflow
                return 0.0  // Approaches 0 for large exponent
            } else if exponent < -700.0 {  // Prevent underflow issues
                return math.max(0.0, -1.0)  // Should be energy dependent in real implementation
            }
            
            var exp_value = math.exp(exponent)
            if math.abs(exp_value - 1.0) < 1e-15 {  // Prevent division by zero
                return math.INFINITY  // Diverges at E = μ
            }
            
            return 1.0 / (exp_value - 1.0)
        }

        // Density of states: N(E) = 8√2πm^(3/2)E^(1/2)/h³
        func density_of_states_3d(energy: Float, particle_mass: Float) -> Float {
            if energy < 0.0 {
                crystal.manifest("Error: Energy must be non-negative")
                return 0.0
            }
            
            var prefactor = 8.0 * math.sqrt(2.0) * math.PI
            var mass_term = math.pow(particle_mass, 1.5)  // m^(3/2)
            var energy_term = math.sqrt(energy)  // E^(1/2)
            var h_cubed = math.pow(PLANCK_CONSTANT, 3.0)  // h³
            
            return (prefactor * mass_term * energy_term) / h_cubed
        }

        // Consciousness-aware quantum operators

        // Quantum coherence measure: Calculate how "coherent" a quantum state is
        func quantum_coherence_measure(statevector: List[math.Complex]) -> Float {
            // Calculate the purity of a quantum state (Tr(ρ²)) for pure states this equals 1
            // For normalized pure states, this will always be 1, so we'll calculate something different
            // This implements a measure of coherence based on superposition
            if statevector.length == 0 {
                return 0.0
            }
            
            // Calculate sum of squares of absolute amplitudes (should be 1 for normalized state)
            var sum_probabilities = 0.0
            for amplitude in statevector {
                var probability = amplitude.magnitude() * amplitude.magnitude()
                sum_probabilities = sum_probabilities + probability
            }
            
            // Calculate how uniform the probabilities are (measure of coherence)
            var avg_probability = 1.0 / statevector.length.toFloat()
            var total_variance = 0.0
            for amplitude in statevector {
                var prob = amplitude.magnitude() * amplitude.magnitude()
                var diff = prob - avg_probability
                total_variance = total_variance + diff * diff
            }
            
            var variance = total_variance / statevector.length.toFloat()
            // Return 1 - variance (higher values = more coherent/superposition state)
            return math.max(0.0, 1.0 - variance * statevector.length.toFloat())
        }

        // Quantum entanglement measure (simplified for 2-qubit systems)
        func entanglement_measure(statevector: List[math.Complex]) -> Float {
            // Simplified entanglement measure for 2-qubit system
            // For a 2-qubit system, this would be based on how the state can/cannot be factored
            if statevector.length != 4 {
                crystal.manifest("Warning: Entanglement measure simplified for 2-qubit states")
                return 0.0  // Simplified implementation for 2-qubits only
            }
            
            // Calculate concurrence for 2-qubit pure state
            var psi00 = statevector[0]  // |00⟩
            var psi01 = statevector[1]  // |01⟩ 
            var psi10 = statevector[2]  // |10⟩
            var psi11 = statevector[3]  // |11⟩
            
            // For 2-qubit pure state, concurrence C = |⟨ψ|σ_y ⊗ σ_y|ψ*⟩|
            // Where σ_y is the Pauli Y matrix
            var concurrence = math.abs(
                psi00.multiply(psi11).subtract(psi01.multiply(psi10)).multiply_scalar(2.0).real
            )
            
            return math.min(1.0, concurrence)  // Clamp to [0,1] range
        }
    }
}